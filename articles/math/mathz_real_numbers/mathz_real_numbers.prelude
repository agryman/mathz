%
% fuzzlib.x
%
% This file is part of fuzz2000
% Copyright (c) 1982--2006 J. M. Spivey
% All rights reserved
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
% 1. Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
% 2. Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
% 3. The name of the author may not be used to endorse or promote products
%    derived from this software without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
% IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
% OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
% IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
% SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
% PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
% OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
% WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
% OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
% ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
% 
% $Id: fuzzlib.x,v 1.2 2007-02-16 12:45:13 mike Exp $
%

%%token $"\bind" 335
%%token $"\bsup" 262
%%token $"\cross" 266
%%token $"\defs" 268
%%token $"\ELSE" 333
%%token $"\esup" 275
%%token $"\exists" 277
%%token $"\exists_1" 278
%%token $"false" 280
%%token $"\forall" 282
%%token $"\hide" 284
%%token $"\iff" 273
%%token $"\IF" 331
%%token $"\implies" 285
%%token $"\in" 286
%%token $"\inrel" 329
%%token $"\lambda" 289
%%token $"\land" 258
%%token $"\langle" 334
%%token $"\lbag" 290
%%token $"\ldata" 291
%%token $"\LET" 292
%%token $"\limg" 293
%%token $"\lnot" 296
%%token $"\lor" 298
%%token $"\mid" 124
%%token $"\mu" 294
%%token $"\pipe" 299
%%token $"\power" 300
%%token $"\pre" 301
%%token $"\project" 302
%%token $"\rangle" 336
%%token $"\rbag" 303
%%token $"\rdata" 304
%%token $"\rimg" 305
%%token $"\semi" 281
%%token $"\spot" 64
%%token $"\THEN" 332
%%token $"\theta" 306
%%token $"true" 307
%%token $"\vdash" 309
%%token $"\where" 310
%%token $"==" 272
%%token $"%%ingen" 312
%%token $"%%inop" 313
%%token $"%%inrel" 314
%%token $"%%pregen" 316
%%token $"%%prerel" 317
%%token $"%%postop" 315
%%token $"%%type" 318
%%token $"%%tame" 319
%%token $"%%pname" 320
%%token $"%%ignore" 338
%%token $"%%debug" 340
%%token $"%%line" 341
%%token $"\begin{axdef}" 259
%%token $"\begin{gendef}" 260
%%token $"\begin{schema}" 261
%%token $"\begin{zed}" 264
%%token $"\begin{syntax}" 263
%%token $"\end{axdef}" 270
%%token $"\end{gendef}" 271
%%token $"\end{schema}" 274
%%token $"\end{zed}" 279
%%token $"\end{syntax}" 276

%%inop \mapsto							1
%%inop \upto							2
%%inop + - \cup \setminus \cat \uplus \uminus			3
%%inop * \div \mod \cap \circ \comp \filter \extract \otimes	4
%%inop \oplus \bcount						5
%%inop \dres \rres \ndres \nrres				6
%%postop \plus \star \inv
%%inrel \neq \notin \subseteq \subset < \leq \geq > \inbag \partition
%%inrel \prefix \subbageq \suffix \inseq
%%prerel \disjoint
%%ingen \rel \fun \pinj \inj \psurj \surj \bij \ffun \finj
%%pregen \power_1 \id \finset \iseq
%%ignore \quad \qquad

%%type \pfun \nat \seq \bag
\begin{gendef}[X]
	\finset \_: \power (\power X)
\end{gendef}
\begin{gendef}[X,Y]
	\_ \rel \_, \_ \ffun \_: \power (\power (X \cross Y)) \\
	\_ \fun \_: \power (X \pfun Y)
\end{gendef}
%%type \rel \ffun \finset

\begin{axdef}
	-: \num \fun \num \\
        \_ + \_ , \_ - \_ , \_ * \_: \num \cross \num \fun \num \\
        \_ \div \_ , \_ \mod \_: 
		\num \cross \num \pfun \num \\
        \_ < \_ , \_ \leq \_ , \_ \geq \_ , \_ > \_: 
		\num \rel \num \\
	\nat_1: \power \nat \\
        succ: \nat \fun \nat \\
	\_ \upto \_: \num \cross \num \fun \power \num \\
        min: \power \num \pfun \num \\
        max: \power \num \pfun \num
\end{axdef}

\begin{gendef}[X]
        \_ \neq \_: X \rel X \\
        \_ \notin \_: X \rel \power X \\
	\empty, \emptyset: \power X \\
	\_ \subseteq \_ , \_ \subset \_: \power X \rel \power X \\
	\power_1 \_: \power (\power X) \\
        \_  \cup \_ , \_ \cap \_ , \_ \setminus \_:
                \power X \cross \power X \fun \power X \\
        \bigcup, \bigcap: \power (\power X) \fun \power X \\
	\id \_: X \rel X \\
        \_\plus, \_\star: (X \rel X) \fun (X \rel X) \\
        iter: \num \fun (X \rel X) \fun (X \rel X) \\
	\finset_1 \_: \power (\finset X) \\
        \#: \finset X \fun \nat \\
	\seq_1 \_, \iseq \_: \power (\seq X) \\
        \_ \cat \_ :  \seq X \cross \seq X \fun \seq X \\
        head, last: \seq X \pfun X \\
        tail, front: \seq X \pfun \seq X \\
        rev: \seq X \fun \seq X \\
        \_ \filter \_: \seq X \cross \power X \fun \seq X \\
        \_ \extract \_: \power \nat \cross \seq X \pfun \seq X \\
	squash: (\nat \ffun X) \pfun \seq X \\
	\_\prefix\_, \_\suffix\_, \_\inseq\_: \seq X \rel \seq X \\
        \dcat: \seq (\seq X) \fun \seq X \\
        count: \bag X \fun (X \fun \nat) \\
	\_\bcount\_: \bag X \cross X \fun \nat \\
        \_ \inbag \_: X \rel \bag X \\
	\_ \subbageq \_: \bag X \rel \bag X \\
        \_ \uplus \_, \_ \uminus \_: \bag X \cross \bag X \fun \bag X \\
	\_ \otimes \_: \nat \cross \bag X \fun \bag X \\
        items: \seq X \fun \bag X
\end{gendef}

\begin{gendef}[X,Y]
        first: X \cross Y \fun X \\
        second: X \cross Y \fun Y \\
        \_ \mapsto \_: X \cross Y \fun X \cross Y \\
        \dom: (X \rel Y) \fun \power X \\
        \ran: (X \rel Y) \fun \power Y \\
        \_ \dres \_: \power X \cross (X \rel Y) \fun (X \rel Y) \\
        \_ \rres \_: (X \rel Y) \cross \power Y \fun (X \rel Y) \\
        \_ \ndres \_: \power X \cross (X \rel Y) \fun (X \rel Y) \\
        \_ \nrres \_: (X \rel Y) \cross \power Y \fun (X \rel Y) \\
        \_\inv: (X \rel Y) \fun (Y \rel X) \\
        \_\limg\_\rimg: (X \rel Y) \cross \power X \fun \power Y \\
        \_ \oplus \_: (X \rel Y) \cross (X \rel Y) \fun (X \rel Y) \\
	\_ \pinj \_, \_ \inj \_, \_ \psurj \_, 
	\_ \surj \_, \_ \bij \_, \_ \finj \_: \power(X \pfun Y) \\
        \disjoint \_: \power (X \pfun \power Y) \\
        \_ \partition \_: (X \pfun \power Y) \rel \power Y
\end{gendef}

\begin{gendef}[X,Y,Z]
        \_ \comp \_: (X \rel Y) \cross (Y \rel Z) \fun (X \rel Z) \\
	\_ \circ \_: (Y \rel Z) \cross (X \rel Y) \fun (X \rel Z)
\end{gendef}

%%pname \pfun $"-+>"
%%pname \ffun $"-++>"
%%pname \rel $"<->"
%%pname \seq $"seq"
%%pname \bag $"bag"
%%pname \finset $"F"
%%pname \nat $"NN"
%%pname \num $"ZZ"
%%pname \upto $".."
%%pname \# $"#"
%%pname \power_1 $"P_1"
%%pname \id $"id"
%%pname \mapsto $"|->"
%%pname \dom $"dom"
%%pname \ran $"ran"
%%pname \fun $"-->"
%%pname \pinj $">+>"
%%pname \inj $">->"
%%pname \psurj $"-+>>"
%%pname \surj $"-->>"
%%pname \bij $">->>"
%%pname \finj $">++>"
%%pname \disjoint $"disjoint"
%%pname \partition $"partition"

%%tame \cup \cap \setminus \bigcup \bigcap count \uplus items
%%tame \plus \cat head last tail front rev \filter \dcat
%%tame first second \mapsto \dom \ran \dres \rres \ndres \nrres 
%%tame \inv \limg\rimg \oplus \comp \circ
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{amsmath}
\ProvidesPackage{mathz_core}[2022/11/29 mathz Library Core Definitions]

% formal parameters for generic constructions
\newcommand{\genA}{\mathsf{a}}
\newcommand{\genB}{\mathsf{b}}
\newcommand{\genC}{\mathsf{c}}
\newcommand{\genD}{\mathsf{d}}
\newcommand{\genE}{\mathsf{e}}
\newcommand{\genF}{\mathsf{f}}
\newcommand{\genG}{\mathsf{g}}
\newcommand{\genH}{\mathsf{h}}
\newcommand{\genI}{\mathsf{i}}
\newcommand{\genJ}{\mathsf{j}}
\newcommand{\genK}{\mathsf{k}}
\newcommand{\genL}{\mathsf{l}}
\newcommand{\genM}{\mathsf{m}}
\newcommand{\genN}{\mathsf{n}}
\newcommand{\genO}{\mathsf{o}}
\newcommand{\genP}{\mathsf{p}}
\newcommand{\genQ}{\mathsf{q}}
\newcommand{\genR}{\mathsf{r}}
\newcommand{\genS}{\mathsf{s}}
\newcommand{\genT}{\mathsf{t}}
\newcommand{\genU}{\mathsf{u}}
\newcommand{\genV}{\mathsf{v}}
\newcommand{\genW}{\mathsf{w}}
\newcommand{\genX}{\mathsf{x}}
\newcommand{\genY}{\mathsf{y}}
\newcommand{\genZ}{\mathsf{z}}

% arbitrary sets used in theorems, remarks, and examples involving generic constructs
\newcommand{\setA}{\mathsf{A}}
\newcommand{\setB}{\mathsf{B}}
\newcommand{\setC}{\mathsf{C}}
\newcommand{\setD}{\mathsf{D}}
\newcommand{\setE}{\mathsf{E}}
\newcommand{\setF}{\mathsf{F}}
\newcommand{\setG}{\mathsf{G}}
\newcommand{\setH}{\mathsf{H}}
\newcommand{\setI}{\mathsf{I}}
\newcommand{\setJ}{\mathsf{J}}
\newcommand{\setK}{\mathsf{K}}
\newcommand{\setL}{\mathsf{L}}
\newcommand{\setM}{\mathsf{M}}
\newcommand{\setN}{\mathsf{N}}
\newcommand{\setO}{\mathsf{O}}
\newcommand{\setP}{\mathsf{P}}
\newcommand{\setQ}{\mathsf{Q}}
\newcommand{\setR}{\mathsf{R}}
\newcommand{\setS}{\mathsf{S}}
\newcommand{\setT}{\mathsf{T}}
\newcommand{\setU}{\mathsf{U}}
\newcommand{\setV}{\mathsf{V}}
\newcommand{\setW}{\mathsf{W}}
\newcommand{\setX}{\mathsf{X}}
\newcommand{\setY}{\mathsf{Y}}
\newcommand{\setZ}{\mathsf{Z}}
\documentclass{amsart}

\usepackage{mathz_project}
\usepackage{mathz_core}

\usepackage{mathz_preamble}

\addbibresource{mathz_references.bib}

\begin{document}

\title{\mathz\ Library Core Objects}
\author{Arthur Ryman}
\email[Arthur Ryman]{arthur.ryman@gmail.com}
\date{\today}

\begin{abstract}
This article contains \ZN\ definitions for some  \mathz\ library core objects,
namely formal generic parameters and arbitrary sets.
\end{abstract}

\maketitle

\tableofcontents

\section{Introduction}

The \texttt{core} package contains definitions for formal generic parameters and arbitrary sets.

\section{Formal Generic Parameters}

\ZN\ supports the definition of generic constants and schemas which take sets as parameters.
Formal generic parameters are used in these definitions.
It is useful to typographically distinguish formal generic parameters from other objects.
Therefore, as a purely stylistic convention, we use the symbols $\genA, \genB, \dots, \genZ$ to denote formal generic parameters.
These symbols are produced using the \LaTeX\ commands \verb|\genA|, \verb|\genB|, $\dots$, \verb|\genZ|.

For example, define the generic constant $triple[\genT]$ to be the set of all triples of elements of $\genT$ 
where $\genT$ is any set.
\begin{zed}
	triple[\genT] == \genT \cross \genT \cross \genT
\end{zed}

\section{Arbitrary Sets}

In mathematical writing we often need to state theorems, remarks, and examples about generic constructions.
Such statements must hold when each formal generic parameter is replaced by any arbitrary set.
This condition is equivalent to universally quantifying the statement over the set of all sets.
However, \ZN\ does not allow universal quantification over the set of all sets since this leads to the Russell paradox.
In fact, Russell proposed typed set theory as a way to avoid this paradox.

Some formal languages avoid the Russell paradox by making a distinction between sets and types,
and by introducing an explicit hierarchy of type universes in which the collection of all types at a given level belongs to the next level.
Another approach is to distinguish between small sets and large sets, with the set of all small sets being a large set.
\ZN\ avoids the Russel paradox by not allowing universal quantification over types.

In more detail, although \ZN\ is based on typed set theory, 
it does not actually include a syntactic mechanism to represent types. 
New base types are introduced by declaring them as \textit{given sets}.
It is a \ZN\ type error to compare or combine subsets of distinct given sets.
A given set is not a proper subset of any other set, and is therefore a \textit{maximal set}.
Thus, in \ZN, a new type is equated to its maximal set.

As a workaround for the absence in \ZN\ of a way to universally quantify over types, 
we adopt the convention of stating theorems, remarks, and examples that are asserted to hold for arbitrary sets 
by stating them in terms of certain predefined given sets, with the understanding that these 
predefined given sets are completely unconstrained by additional axioms.
We refer to these predefined given sets as \textit{arbitrary sets}.
It is therefore a \mathz\ error to use any of these predefined arbitrary sets outside of the statement of a theorem, remark, or example.

This workaround is similar to the introduction rule for universal quantification in predicate calculus.
To prove a universally quantified statement in predicate calculus, one assumes an arbitrary element and then proves the conclusion for it.
Since the element was arbitrary, one can then universally quantify over it.
Of course, in \mathz\ we will only prove statements for some arbitrary set, and not explicitly quantify over it.

Let the symbols $\setA, \setB, \dots \setZ$ denote these predefined arbitrary sets.
\begin{zed}
	[\setA, \setB, \setC, \setD, \setE, \setF, \setG, \setH, \setI, \setJ, \setK, \setL, \setM, 
	\setN, \setO, \setP, \setQ, \setR, \setS, \setT, \setU, \setV, \setW, \setX, \setY, \setZ]
\end{zed}
These symbols are produced using the \LaTeX\ commands \verb|\setA|, \verb|\setB|, $\dots$, \verb|\setZ|.

For example, consider the following statement which holds for the arbitrary set $\setX$.
\begin{remark}
Equality is reflexive.
\begin{zed}
	\forall x: \setX @ x = x
\end{zed}
\end{remark}

\printbibliography

\end{document}  \NeedsTeXFormat{LaTeX2e}
\RequirePackage{amsmath}
\ProvidesPackage{mathz_sets}[2022/02/01 Z Notation for sets package]

% sets

% families of sets
%%pregen \Fam
\DeclareMathOperator{\Fam}{\mathcal{F}}

% the induced family infix operator
%%inop \inducedFam 6
\newcommand{\inducedFam}{\mathbin{|_{\Fam}}}

% the product family infix operator
%%inop \prodFam 5
\newcommand{\prodFam}{\mathbin{\cross_{\Fam}}}

% the constant function
\DeclareMathOperator{\const}{const}

% the function restriction infix operator
%%inop \restrictU 6
\newcommand{\restrictU}{\mathbin{|}}

% the set of binary digits
\newcommand{\B}{\mathbb{B}}

% the indicator function of a set
%%pregen \indF
\DeclareMathOperator{\indF}{\mathbf{1}}

% the delta function of a set
%%pregen \deltaF
\DeclareMathOperator{\deltaF}{\delta}
\documentclass{amsart}

\usepackage{mathz_core}
\usepackage{mathz_sets}

\usepackage{mathz_preamble}

\addbibresource{mathz_references.bib}

\begin{document}

\title{Sets}
\author{Arthur Ryman}
\email[Arthur Ryman]{arthur.ryman@gmail.com}
\date{\today}

\begin{abstract}
This article contains \ZN\ definitions for 
concepts related to sets.
It has been type checked by \fuzz.
\end{abstract}

\maketitle

\tableofcontents

\section{Introduction}

Typed set theory forms the mathematical foundation of \ZN\cite{spivey-zrm}.
Many set theory concepts are defined in its built-in mathematical toolkit. 
This article augments the toolkit with some additional concepts.
It has been type checked by \fuzz\cite{spivey-fm}.

\section{Binary Digits}

Let $bit$ denote the set of \textit{binary digits}, namely the set $\{ 0, 1\} \subseteq \num$.

\begin{zed}
	bit == \{ 0, 1 \}
\end{zed}

Let the notation $\B$ denote the set of bits.

\begin{zed}
	\B == bit
\end{zed}

\begin{example}
Zero and one are bits, but two isn't.
\begin{zed}
	0 \in \B
\also
	1 \in \B
\also
	2 \notin \B
\end{zed}
\end{example}

\section{Families of Subsets}

Let $\genT$ be a set.
A \textit{family} of subsets of $\genT$ is a set of subsets of $\genT$.
Let $Fam[\genT]$ denote the set of all families of subsets of $\genT$.

\begin{zed}
	Fam[\genT] == \power(\power \genT)
\end{zed}

\begin{example}
The set consisting of the empty set and $\setX$ is a family of subsets of $\setX$.
\begin{zed}
	\{ \emptyset, \setX \} \in Fam[\setX]
\end{zed}
\end{example}

Let the notation $\Fam \genT$ denote the family of subsets of $\genT$ .

\begin{zed}
	\Fam \genT == Fam[\genT]
\end{zed}

\section{Functions}

\subsection{Binary Functions}

Let $\genT$ be a set. A function that maps $\genT$ to $\B$ is called a \textit{binary function} on $\genT$.

\begin{zed}
	binary\_function[\genT] == \genT \fun \B
\end{zed}

\begin{example}
The function that maps the set $\setT$ to $0$ is a binary function.
\begin{zed}
	(\lambda x: \setT @ 0) \in binary\_function[\setT]
\end{zed}
\end{example}

\subsection{Constant Functions}

Let $\genT$ and $\genU$ be sets and let $c$ be some given element of  $\genU$.
The mapping $f$ that sends every element $x$ of $\genT$ to $c$ is called the \textit{constant function} on $\genT$ with value $c$.

\begin{schema}{ConstantFunction}[\genT, \genU]
	c: \genU \\
	f: \genT \fun \genU
\where
	f = (\lambda x: \genT @ c)
\end{schema}

Let $constant\_function~c$ denote the constant function $f$ on $\genT$ with value $c$.

\begin{zed}
	constant\_function[\genT, \genU] == \{~ConstantFunction[\genT, \genU] @ c \mapsto f ~\}
\end{zed}

\begin{remark}
The mapping $constant\_function$ maps each element $c \in \setU$ to a function $\setT \fun \setU$.
\begin{zed}
	constant\_function[\setT, \setU] \in \setU \fun (\setT \fun \setU)
\end{zed}
\end{remark}

Let the notation $\const c$ denote the constant function with value $c$.

\begin{zed}
	\const[\genT, \genU] == constant\_function[\genT, \genU]
\end{zed}

\begin{remark}
\begin{zed}
	\forall c: \setU; x: \setT @ \const[\setT, \setU] c~x = c
\end{zed}
\end{remark}

\subsection{Delta Functions}

Let $\genT$ be a set and let $x, y \in \genT$. 
Define the \textit{equality indicator bit} $z$ of $(x, y)$ to be $1$ if $x = y$ and $0$ otherwise.

\begin{schema}{EqualityIndicator}[\genT]
	x, y: \genT \\
	z: \B
\where
	z = \IF x = y \THEN 1 \ELSE 0
\end{schema}

Define the delta function $delta(x, y)$ to be the equality indication bit of $(x, y)$.

\begin{zed}
	delta[\genT] == \{~ EqualityIndicator[\genT] @ (x, y) \mapsto z ~\}
\end{zed}

\begin{remark}
\begin{zed}
	delta[\setX] \in \setX \cross \setX \fun \B
\end{zed}
\end{remark}

\begin{example}
\begin{zed}
	delta(0, 0) = 1
\also
	delta(0, 1) = 0
\end{zed}
\end{example}

\begin{remark}
\begin{zed}
	\forall x: \setX @ \\
	\t1	delta(x, x) = 1
\end{zed}
\end{remark}

Let the notation $\deltaF \genT$ denote the delta function $delta[\genT]$.

\begin{zed}
	\deltaF \genT == delta[\genT]
\end{zed}

\begin{example}
\begin{zed}
	(\deltaF \num) (0,1) = 0
\end{zed}
\end{example}

\subsection{Function Restriction}

Let $\genT$ and $\genU$ be sets, let $f: \genT \fun \genU$, and let $T \subseteq \genT$ be a subset.
Let $g$ denote the restriction of $f$ to $T$.

\begin{schema}{FunctionRestriction}[\genT, \genU]
	f: \genT \fun \genU \\
	T: \power \genT \\
	g: \genT \pfun \genU
\where
	g = T \dres f
\end{schema}

Let  $restriction(f, T)$ denote the restriction of $f$ to $T$.

\begin{zed}
	restriction[\genT, \genU] == \{~ FunctionRestriction[\genT, \genU] @ (f, T) \mapsto g ~\}
\end{zed}

\begin{remark}
\begin{zed}
	restriction[\setT, \setU] \in (\setT \fun \setU) \cross \power \setT \fun (\setT \pfun \setU)
\end{zed}
\end{remark}

Let the notation $f \restrictU T$ denote the restriction of $f$ to $T$.

\begin{zed}
	(\_ \restrictU \_)[\genT, \genU] == restriction[\genT, \genU]
\end{zed}

\begin{remark}
Function restriction is domain restriction with arguments reversed.
\begin{zed}
	\forall FunctionRestriction[\setT, \setU] @ \\
	\t1	f \restrictU T = T \dres f
\end{zed}
\end{remark}

\subsection{Indicator Functions}

Let $\genT$ be a set and let $X \subseteq \genT$ be a subset.
The \textit{indicator function}  $f$  of $X$ maps each element $a \in \genT$ to 1 if $a \in X$ and 0 otherwise.
The indicator function is also referred to as the \textit{characteristic function} of $X$.

\begin{schema}{IndicatorFunction}[\genT]
	X: \power \genT \\
	f: \genT \fun \B
\where
	f = (\lambda a: \genT @ \IF a \in X \THEN 1 \ELSE 0)
\end{schema}

Let $indicator\_function~X$ denote the indicator function of $X$.

\begin{zed}
	indicator\_function[\genT] == \{~ IndicatorFunction[\genT] @ X \mapsto f ~\}
\end{zed}

\begin{remark}
For each subset $X \subseteq \setT$, the indicator function of $X$ is a binary function on $\setT$.
\begin{zed}
	indicator\_function[\setT] \in \power \setT \fun \setT \fun \B
\end{zed}
\end{remark}

We introduce the prefix generic symbol $(\indF \_)$ where $(\indF \genT)X = indicator\_function[\genT] X$.

\begin{zed}
	\indF \genT == indicator\_function[\genT]
\end{zed}

\begin{remark}
The domain of the range restriction of the indicator function of a set $X$ to the range $\{1\}$ is $X$.
\begin{zed}
	\forall X: \power \setT @ \\
	\t1	\dom((\indF \setT)X \rres \{1\}) = X
\end{zed}
\end{remark}

\section{The Support of a Function}

Let $\genT$ be a set and let $f$ be an integer-valued function on $\genT$.
The \textit{support} $S$ of $f$ is the set of elements $x$ in $\genT$  that take nonzero values.

\begin{schema}{Support}[\genT]
	f: \genT \fun \num \\
	S: \power \genT
\where
	S = \{~ x: \genT | f~x \neq 0 ~\}
\end{schema}

Let $support~f$ denote the support $S$ of $f$.

\begin{zed}
	support[\genT] == \{~ Support[\genT] @ f \mapsto S ~\}
\end{zed}

\begin{example}
The support of the indicator function of a set $X$ is $X$.
\begin{zed}
	\forall X: \power \setT @ \\
	\t1 support((\indF \setT)X) = X
\end{zed}
\end{example}

An integer-valued function is said to have \textit{finite support} if its support is a finite set.

\begin{schema}{FiniteSupport}[\genT]
	Support[\genT]
\where
	S \in \finset \genT
\end{schema}

Let $finite\_support[\genT]$ denote the set of all integer-valued functions on $\genT$ that have finite support.

\begin{zed}
	finite\_support[\genT] == \{~ FiniteSupport[\genT] @ f ~\}
\end{zed}

\begin{remark}
\begin{zed}
	finite\_support[\setT] \subseteq \setT \fun \num
\end{zed}
\end{remark}

\printbibliography

\end{document}\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{mathz_integers}[2022/02/01 Z Notation for integers package]

% the exponentiation infix operator x ** n
%%inop \expN 5
\newcommand{\expN}{\mathbin{**}}

%%inop \foo 3
\newcommand{\foo}{\mathbin{+}}

% the divisibility infix relation x | y for integers
%%inrel \divides
\newcommand{\divides}{\mathrel{\mid}}

% the addition infix operator x + y for integer sequences
%%inop \addSeqZ 3
\newcommand{\addSeqZ}{\mathbin{+}}
\documentclass{amsart}

\usepackage{mathz_integers}

\usepackage{mathz_preamble}

\addbibresource{mathz-references.bib}

\begin{document}

\title{Integers}
\author{Arthur Ryman}
\email[Arthur Ryman]{arthur.ryman@gmail.com}
\date{\today}

\begin{abstract}
This article contains \ZN\ definitions for 
concepts related to the integers, $\num$.
It has been type checked by \fuzz.
\end{abstract}

\maketitle

\tableofcontents

\section{Introduction}

The integers $\num$ are built-in to \ZN.
This article provides definitions for some related objects so that they can be used and type checked in formal Z specifications.

\section{Exponentiation}

Let $x \in \num$ and $n \in \nat$. Then $x$ raised to the exponent $n$ is the product of $x$ multiplied by itself $n$ times,
with the convention that for $n = 0$ the result is $1$.
Let $exp(x, n)$ denote the result.

\begin{axdef}
	exp: \num \cross \nat \fun \num
\where
	\forall x: \num @ exp(x, 0) = 1
\also
	\forall x: \num; n: \nat_1 @ exp(x, n) = x * exp(x, n - 1)
\end{axdef}

\begin{example}
\begin{zed}
	exp(5,2) = 25
\end{zed}
\end{example}

\begin{remark}
\begin{zed}
	\forall x: \num @ \\
	\t1	exp(x, 0) = 1
\end{zed}
\end{remark}

\begin{remark}
\begin{zed}
	\forall x: \num @ \\
	\t1	exp(x, 1) = x
\end{zed}
\end{remark}

\begin{remark}
\begin{zed}
	\forall x: \num; n, m: \nat @ \\
	\t1	exp(x, n + m) = exp(x, n) * exp(x, m)
\end{zed}
\end{remark}

\begin{remark}
\begin{zed}
	\forall x, y: \num; n: \nat @ \\
	\t1	exp(x * y, n) = exp(x, n) * exp(y, n)
\end{zed}
\end{remark}

Exponentiation is normally denoted $x^n$ but \ZN\ cannot reproduce that.
Instead we use the infix operator notation that is common to programming languages such as FORTRAN and Python.
Define the notation $x \expN n = exp(x, n)$.

\begin{zed}
	(\_ \expN \_) == exp
\end{zed}

\begin{example}
\begin{zed}
	5 \expN 2 = 25
\end{zed}
\end{example}

\section{Divisibility}

This section defines \textit{divisibility} of integers.

Given integers $x$ and $y$ we say that $x$ \textit{divides} $y$ if there is some integer $q$ such 
that $q x = y$.

\begin{schema}{Divides}
	x, y, q : \num
\where
	q * x = y
\end{schema}

Let $divides$ denote the divisibility relation between integers
where $(x,y) \in divides$ means that $x$ divides $y$.

\begin{zed}
	divides == \{~ Divides @ x \mapsto y ~\}
\end{zed}

\begin{remark}
\begin{zed}
	divides \in \num \rel \num
\end{zed}
\end{remark}

We introduce the usual infix notation $x \divides y$ to denote that $(x, y) \in divides$.
\begin{zed}
(\_ \divides \_) == divides
\end{zed}

\begin{example}
The integer $7$ divides $42$ because $6 * 7 = 42$.

\begin{zed}
	7 \divides 42
\end{zed}
\end{example}

\begin{remark}
Every integer $x$ divides $0$ because $0 * x = 0$.

\begin{zed}
	\forall x : \num @ x \divides 0
\end{zed}
\end{remark}

\section{Divisors}

Let $x$ be a nonzero integer that divides the integer $y$.
We say that $x$ is a \textit{divisor} of $y$.

\begin{schema}{Divisor}
	Divides
\where
	x \neq 0
\end{schema}

Let the relation $(x, y) \in is\_divisor\_of$ denote that $x$ is a divisor of $y$.

\begin{zed}
	is\_divisor\_of == \{~ Divisor @ x \mapsto y ~\}
\end{zed}

Let the set $divisors(y)$ denote the set of all divisors of the integer $y$.

\begin{zed}
	divisors == (\lambda y: \num @ \{~ x : \num | (x, y) \in is\_divisor\_of  ~\})
\end{zed}

\begin{remark}
\begin{zed}
	divisors \in \num \fun \power \num
\end{zed}
\end{remark}

\begin{example}
The integer $6$ has the following divisors.

\begin{zed}
	divisors(6) = \{-6, -3, -2, -1, 1, 2, 3, 6 \}
\end{zed}
\end{example}

Let the set $positive\_divisors(y)$ denote the set of all positive divisors of the integer $y$.

\begin{zed}
	positive\_divisors == (\lambda y: \num @ divisors(y)  \cap \nat_1)
\end{zed}

\begin{remark}
\begin{zed}
	positive\_divisors \in \num \fun \power \nat_1
\end{zed}
\end{remark}

\begin{example}
The integer $6$ has the following positive divisors.
\begin{zed}
	positive\_divisors(6) = \{1, 2, 3, 6 \}
\end{zed}
\end{example}

\section{Prime Numbers}

An integer $p$ is \textit{prime} if it is greater than one 
and only has one and itself as positive divisors.

\begin{schema}{Prime}
	p: \num
\where
	p > 1
\also
	positive\_divisors(p) = \{ 1, p \}
\end{schema}
\begin{itemize}
	\item $p$ is greater than $1$.
	\item $1$ and $p$ are the only positive divisors of $p$.
\end{itemize}

\begin{example}
The integer $2$ is prime.

\begin{zed}
	\LET p == 2 @ \\
	\t1	Prime
\end{zed}
\end{example}

Let $primes$ denote the set of all primes.

\begin{zed}
	primes == \{~ Prime @ p ~\}
\end{zed}

\begin{remark}
\begin{zed}
	primes \subset \nat_1
\end{zed}
\end{remark}

\begin{example}
The natural numbers $2, 3, 5,$ and $7$ are primes.

\begin{zed}
	\{2, 3, 5, 7\} \subseteq primes
\end{zed}
\end{example}

\section{Addition of Integer Sequences}

Let $l$ be a natural number and
let $x$ and $y$ be two integer sequences of length $l$.
Their sum $z = x + y$ is the integer sequence of length $l$ defined by pointwise addition
of the terms in $x$ and $y$.

\begin{schema}{AddIntegerSequences}
	l : \nat \\
	x, y, z : \seq \num
\where
	l = \# x = \# y
\also
	z = (\lambda i : 1 \upto l @ x~i + y~i)
\end{schema}
\begin{itemize}
	\item The sequence $z$ is defined by pointwise addition of the sequences $x$ and $y$.
\end{itemize}

Let the function $add\_int\_seq(x, y) = z$ be the sum of two equal-length integer sequences.

\begin{zed}
	add\_int\_seq == \{~ AddIntegerSequences @ (x, y) \mapsto z ~\}
\end{zed}

\begin{remark}
Addition is a partial function on the set of all pairs of integer sequences.
\begin{zed}
	add\_int\_seq \in \seq \num \cross \seq \num \pfun \seq \num
\end{zed}
\end{remark}

We introduce the usual infix notation $x \addSeqZ y = add\_int\_seq(x, y)$.

\begin{zed}
	(\_ \addSeqZ \_) == add\_int\_seq
\end{zed}

\printbibliography

\end{document}\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{mathz_topological_spaces}[2022/02/01 Z Notation for topological spaces package]
\RequirePackage{amsmath}

% continuous mappings between topological spaces
\DeclareMathOperator{\CzeroTT}{C^0}

% topological decoration on operators
\newcommand{\topology}{\mathsf{top}}

% the induced topological space infix operator
\newcommand{\inducedTopSp}{\mathbin{|_\topology}}
%%inop \inducedTopSp 6

% the product topology infix operator
\newcommand{\prodTop}{\mathbin{\cross_\topology}}
%%inop \prodTop 5

% the product topological space infix operator
\newcommand{\prodTopSp}{\mathbin{\cross_\topology}}
%%inop \prodTopSp 5
\documentclass{amsart}

\usepackage{mathz_core}
\usepackage{mathz_sets}
\usepackage{mathz_topological_spaces}
\usepackage{mathz_preamble}

\addbibresource{mathz-references.bib}

\begin{document}

\title{Topological Spaces}
\author{Arthur Ryman}
\email[Arthur Ryman]{arthur.ryman@gmail.com}
\date{\today}

\begin{abstract}
This article contains Z Notation definitions for topological spaces and related concepts.
It has been type checked by \fuzz.
\end{abstract}

\maketitle

\tableofcontents

\section{Topological Spaces}

\subsection{$Topology$}

A {\it topology} $\tau$ on $X$ is a family of subsets of $X$, referred to as the {\it open} subsets of $X$, that satisfy the following axioms.

\begin{schema}{Topology}[X]
	\tau: \Fam X
\where
	\emptyset \in \tau
\also
	X \in \tau
\also
	\forall F: \finset \tau @ \bigcap F \in \tau
\also
	\forall F: \power \tau @ \bigcup F \in \tau
\end{schema}

\begin{itemize}
\item The empty set is open.
\item The whole set is open.
\item The intersection of a finite family of open sets is open.
\item The union of any family of open sets is open. 
\end{itemize}

\subsection{$top$ and $tops$}

Let $top[X]$ denote the set of all topologies on $X$.

\begin{gendef}[X]
	top: \power(\Fam X)
\where
	top = \{~ Topology[X] @ \tau ~\}
\end{gendef}

Let $tops[X]$ denote the set of all topologies on subsets $U \subseteq X$.

\begin{gendef}[X]
	tops: \power(\Fam X)
\where
	tops = \bigcup \{~ U: \power X @ top[U] ~\}
\end{gendef}

\subsection{$discrete$ and $indiscrete$}

The {\it discrete} topology on $X$ consists of all subsets of $X$.
The {\it indiscrete} topology on $X$ consists of just $X$ and $\emptyset$.
Let $discrete[X]$ and $indiscrete[X]$ denote the discrete and indiscrete topologies on $X$.

\begin{gendef}[X]
	discrete, indiscrete: \Fam X
\where
	discrete = \power X
\also
	indiscrete =  \{ \emptyset, X \}
\end{gendef}

\begin{example}
Let $\setX$ be an arbitrary set.
Then $discrete[\setX]$ and $indiscrete[\setX]$ are topologies on $\setX$.

\begin{zed}
	discrete[\setX] \in top[\setX] 
\also
	indiscrete[\setX] \in top[\setX]
\end{zed}

\end{example}

\subsection{$topGen$}

\begin{remark}

The intersection of a set of topologies on $X$ is also a topology on $X$.

\end{remark}

Given a family $B$ of subsets of $X$, the topology {\it generated by} $B$ is the intersection of all
topologies that contain $B$.
The set $B$ is referred to as a {\it basis} for the topology it generates.
Let $topGen[X]~B$ denote the topology on $X$ generated by the basis $B$.

\begin{gendef}[X]
	topGen: \Fam X \fun top[X]
\where
	\forall B: \Fam X @ \\
	\t1	topGen~B = \bigcap \{~ \tau: top[X] | B \subseteq \tau ~\}
\end{gendef}

\begin{example}
Let $\setX$ be an arbitrary set.

\begin{zed}
	topGen[\setX] \emptyset = indiscrete[\setX]
\also
	topGen[\setX] \{ \emptyset \} = indiscrete[\setX]
\also
	topGen[\setX] \{ \setX \} = indiscrete[\setX]
\end{zed}

\end{example}

\subsection{$topSpace$}

Let $X$ be a set.
A {\it topological space} is a pair $(X, \tau)$ where $\tau$ is a topology on $X$.
Let $topSpace[X]$ denote the set of all topological spaces $(X,\tau)$.

\begin{zed}
	topSpace[X] == \{~ \tau: top[X] @ (X, \tau) ~\}
\end{zed}

\begin{example}
Let $\setX$ be an arbitrary set.

\begin{zed}
	(\setX, indiscrete[\setX]) \in topSpace[\setX]
\also
	(\setX, discrete[\setX]) \in topSpace[\setX]
\end{zed}


\end{example}

\subsection{$topSpaces$}

Let $topSpaces[t]$ dentote the set of all topological spaces $(X,\tau)$ where $X$ is a subset of $t$.

\begin{gendef}[t]
	topSpaces: \power t \rel \Fam t
\where
	topSpaces = \{~ X: \power t; \tau: \Fam t | \tau \in top[X] ~\}
\end{gendef}

\begin{remark}

\begin{zed}
	topSpace[\setX] \subseteq topSpaces[\setX]
\end{zed}

\end{remark}

\section{Continuous Mappings}

Let $(X,\tau)$ and $(Y,\sigma)$ be topological spaces.

\subsection{$Continuous$}

A mapping $f \in X \fun Y$ is said to be {\it continuous} if the inverse image of every open set is open.

\begin{schema}{Continuous}[X,Y]
	f: X \fun Y \\
	\tau: top[X] \\
	\sigma: top[Y]
\where
	\forall U: \sigma @ \\
	\t1	f\inv\limg U \rimg \in \tau
\end{schema}

\subsection{\zcmd{CzeroTT}}

Let $A$ and $B$ be topological spaces, and
let $\CzeroTT(A,B)$ denote the set of continuous mappings from $A$ to $B$.

\begin{gendef}[X,Y]
	\CzeroTT: topSpace[X] \cross topSpace[Y] \fun \power (X \fun Y)
\where
	\forall \tau: top[X]; \sigma: top[Y] @ \\
	\t1	\LET A == (X, \tau); B == (Y, \sigma) @ \\
	\t2		\CzeroTT(A,B) = \{~ f: X \fun Y | Continuous[X,Y] ~\}
\end{gendef}

\subsection{The Identity Mapping}

\begin{remark}
The identity mapping is continuous.

\begin{zed}
	\forall \tau: top[\setX] @ \\
	\t1	\LET A == (\setX, \tau) @ \\
	\t2		\id \setX \in \CzeroTT(A, A)
\end{zed}

\end{remark}

\begin{remark}
The constant mapping is continuous.

\begin{zed}
	\forall \tau: top[\setX]; \sigma: top[\setY]; c: \setY @ \\
	\t1	\LET A == (\setX, \tau); B == (\setY, \sigma) @ \\
	\t2		\const[\setX,\setY] c \in \CzeroTT(A,B)
\end{zed}

\end{remark}

\subsection{Composition of Continuous Mapping}

\begin{remark}
Let $\setX$, $\setY$, and $\setZ$ be arbitrary sets.
The composition of continuous mappings is a continuous mapping.

\begin{zed}
	\forall A: topSpace[\setX]; B: topSpace[\setY]; C: topSpace[\setZ] @ \\
	\t1	\forall f: \CzeroTT(A, B); g: \CzeroTT(B, C) @ \\
	\t2		g \circ f \in \CzeroTT(A, C)
\end{zed}

\end{remark}

\section{Induced Topology}

Let $A = (X, \tau)$ be a topological space and let $U \subseteq X$ be a subset.
The topology on $X$ {\it induces} a topology on $U$.
This topology is variously referred to as the {\it induced}, {\it relative}, or {\it subspace} topology on $U$.

\subsection{\zcmd{inducedFam}}

Let $\phi$ be a family of subsets of $X$ and let $U$ be a subset of $X$.
The family of subsets of $U$ {\it induced} by $\phi$ is the set of intersections of the members of $\phi$ with $U$.
Let $\phi \inducedFam U$ denote the family on $U$ induced by $\phi$.

\begin{gendef}[X]
	\_ \inducedFam \_:  \Fam X \cross \power X \fun \Fam X
\where
	\forall \phi: \Fam X; U: \power X @ \\
	\t1	\phi \inducedFam U = \{~ Y: \phi @ Y \cap U ~\}
\end{gendef}

\begin{remark}
If $\tau$ is a topology on $X$ then $\tau \inducedFam U$ is a topology on $U$.

\begin{zed}
	\forall \tau: top[\setX]; U: \power \setX @ \\
	\t1	\tau \inducedFam U \in top[U]
\end{zed}

\end{remark}

\subsection{\zcmd{inducedTopSp}}

Let $(X, \tau) \inducedTopSp U$ denote the corresponding induced topological space.

\begin{gendef}[X]
	\_ \inducedTopSp \_: topSpace[X] \cross \power X \fun topSpaces[X]
\where
	\forall \tau: top[X]; U: \power X @ \\
	\t1	(X, \tau) \inducedTopSp U = (U, \tau \inducedFam U)
\end{gendef}

\section{Product Topology}

Let $(X, \tau)$ and $(Y, \sigma) $ be topological spaces.
There is a natural topology on $X \cross Y$ generated by the products of the sets in $\tau$ and $\sigma$.

\subsection{\zcmd{prodFam}}

Let $X$ and $Y$ be sets and let $\phi$ and $\psi$ be families on them.
The product of these families is the family that consists of the products of the sets in them and is a family on $X \cross Y$.
Let $\phi \prodFam \psi$ denote the product of the families.

\begin{gendef}[X,Y]
	\_ \prodFam \_ : \Fam X \cross \Fam Y \fun \Fam(X \cross Y)
\where
	\forall \phi: \Fam X; \psi: \Fam Y @ \\
	\t1	\phi \prodFam \psi = \{~ U: \phi; V: \psi @ U \cross V ~\}
\end{gendef}

\begin{remark}

If $\tau$ and $sigma$ are topologies then $\tau \prodFam \sigma$ is not, in general, a topology.
However, we can use it to generate a topology.

\end{remark}

\subsection{\zcmd{prodTop}}

Let $\tau \prodTop \sigma$ denote the topology generated by $\tau \prodFam \sigma$.

\begin{gendef}[X,Y]
	\_ \prodTop \_: top[X] \cross top[Y] \fun top[X \cross Y]
\where
	\forall \tau: top[X]; \sigma: top[Y] @ \\
	\t1	\tau \prodTop \sigma = topGen(\tau \prodFam \sigma)
\end{gendef}

\subsection{\zcmd{prodTopSp}}

Let $(X, \tau) \prodTop (Y, \sigma)$ denote the product topological space.

\begin{gendef}[X,Y]
	\_ \prodTopSp \_: topSpace[X] \cross topSpace[Y] \fun topSpace[X \cross Y]
\where
	\forall \tau: top[X]; \sigma: top[Y] @ \\
	\t1	(X, \tau) \prodTopSp (Y, \sigma) = (X \cross Y, \tau \prodTop \sigma)
\end{gendef}

\printbibliography

\end{document}\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{mathz_groups}[2022/02/01 Z Notation for groups package]

\RequirePackage{amsmath}

% groups

% binary operations
%%pregen \magma
\DeclareMathOperator{\magma}{magma}

% magma homomorphisms
\DeclareMathOperator{\homMagma}{hom_{mgm}}

% semigroups

% the set of all semigroups
%%pregen \semigroup
\DeclareMathOperator{\semigroup}{semigroup}

\DeclareMathOperator{\homSemigroup}{hom_{sg}}

% monoids

% the set of all monoids
%%pregen \monoid
\DeclareMathOperator{\monoid}{monoid}

\DeclareMathOperator{\homMonoid}{hom_{mnd}}

% groups

%%pregen \group
\DeclareMathOperator{\group}{group}

\DeclareMathOperator{\homGroup}{hom_{grp}}

% group identity element
\newcommand{\oneG}{1}

%%inop \mulA \mulB 4
\newcommand{\mulA}{\mathbin{*}}
\newcommand{\mulB}{\mathbin{*}}

% variables used for mathematical structures
\newcommand{\strucA}{\mathbf{A}}
\newcommand{\strucB}{\mathbf{B}}
\newcommand{\strucC}{\mathbf{C}}

%%inop \mulG \timesG 4
\newcommand{\mulG}{\mathbin{*}}
\newcommand{\timesG}{\mathbin{\times}}

%%postop \invG \daggerG
\newcommand{\invG}{^{-1}}
\newcommand{\daggerG}{^{\dagger}}

% Abelian groups

%%pregen \abgroup
\DeclareMathOperator{\abgroup}{abgroup}

%%inop \addG 3
\newcommand{\addG}{\mathbin{+}}

\newcommand{\zeroG}{0}

\DeclareMathOperator{\negG}{-}
\documentclass{amsart}

\usepackage{mathz_core}
\usepackage{mathz_sets}
\usepackage{mathz_integers}
\usepackage{mathz_groups}

\usepackage{mathz_preamble}

\addbibresource{mathz-references.bib}

\begin{document}

\title{Groups}
\author{Arthur Ryman}
\email[Arthur Ryman]{arthur.ryman@gmail.com}
\date{\today}

\begin{abstract}
This article contains Z Notation definitions for groups and some related objects, namely magmas, semigroups, and monoids.
It has been type checked with \fuzz.
\end{abstract}

\maketitle

\tableofcontents

\section{Introduction}

Groups are ubiquitous throughout mathematics and physics.
This article defines groups, and their homomorphisms,
gradually building up the definitions in terms of some simpler, related mathematical objects,
namely magmas, semigroups, and monoids.

These objects are \textit{mathematical structures}, namely sets of elements equipped with additional features.
The set of elements of a structure is often referred to as its \textit{carrier}.
In particular, magmas, semigroups, monoids, and groups are \textit{algebraic structures}. 

\section{Structures}

In normal mathematical writing, authors do not need to distinguish between a structure and it carrier
because the structure is usually clear from context.
For example, one typically see statements such as:  
``Let $G$ be a group and let $g$ be an element of $G$.''
Here the first instance of the variable $G$ stands for the structure while the second stands for its carrier.

However, a set of elements may have more than one structure in a given context.
For example, the set of integers has the distinct binary operations of addition and multiplication.
In such cases it may be ambiguous if only the carrier is specified.
Furthermore, if the mathematics is expressed using a formal language, distinct mathematical objects
must be referred to using distinct names or expressions.

In order to distinguish between structures and their carriers, 
this article adopts the common practice of defining structures as \textit{tuples}
consisting of a carrier together with one or more additional features.
This article also adopts the notational convention of using bold font variables, e.g. $\strucA, \strucB, \strucC$,
to denote structures, and the corresponding Roman font variables, e.g. $A, B, C$, to denote their carriers.

TO DO: update the article to define structures as tuples of a carrier and a binary operation.
Also better integrate the informal text notation with the formal text by using the variable names in the schema.

\section{Carriers}

Let $\genT$ be a set and let $elements$ be a nonempty subset of $\genT$.
The set $\genT$ can be thought of as the \textit{universe of discourse} from which the elements are drawn.
The set $elements$ in the context of some mathematical structure is said to be the \textit{carrier} of that structure.
Such a structure is said to be \textit{on} or \textit{over} its set of elements
and \textit{in} the universe from which its elements are drawn.
\begin{schema}{Carrier}[\genT]
	elements: \power_1 \genT
\end{schema}

Let $\strucA$ and $\strucB$ be structures with carriers $A$ and $B$.
A \textit{carrier map} from $\strucA$ to $\strucB$ is a triple $(f, A, B)$ where $f$ is a function from $A$ to $B$.
In this situation, the carrier $A$ of the source structure $\strucA$ is called the \textit{domain} of the map 
and the carrier $B$ of the target structure $\strucB$ is called its \textit{codomain}.

TO DO: The following schemas do not mention the variables introduced above. 
Fix this by introducing schemas that incorporate the variables.
Also note that the text mentions structures but does not formally define them.
Perhaps eliminate the Carrier schema and start with the Magma schema.

\begin{zed}
	Carrier\_Domain[\genT] \defs Carrier[\genT][domain / elements]
\also
	Carrier\_Codomain[\genT] \defs Carrier[\genT][codomain / elements]
\end{zed}

\begin{schema}{Carrier\_Map}[\genT, \genU]
	Carrier\_Domain[\genT] \\
	Carrier\_Codomain[\genU] \\
	function: \genT \pfun \genU
\where
	function \in domain \fun codomain
\end{schema}

\begin{remark}
The domain of a carrier map is uniquely determined by its function.
\begin{zed}
	\forall Carrier\_Map[\setT, \setU] @ \dom function = domain
\end{zed}
\end{remark}

\begin{remark}
The codomain of a carrier map is a superset of the range of its function.
This means that carrier maps that have the same function but distinct codomains are distinct carrier maps.
\begin{zed}
	\forall Carrier\_Map[\setT, \setU] @ \ran function \subseteq codomain
\end{zed}
\end{remark}

Let $carrier\_maps[\genT]$ denote the set of all carrier maps of structures in $\genT$.
\begin{zed}
	carrier\_maps[\genT] == \{~ Carrier\_Map[\genT, \genT] @ (function, domain, codomain) ~\}
\end{zed}

Let $A, B, C$ be carriers of some structures.
Consider functions $f: A \fun B$, $g: B \fun C$, and $h: A \fun C$.
\begin{zed}
	Carrier\_Map\_fAB[\genT, \genU] \defs Carrier\_Map[\genT, \genU][f / function, A / domain, B / codomain]
\also
	Carrier\_Map\_gBC[\genT, \genU] \defs Carrier\_Map[\genT, \genU][g / function, B / domain, C / codomain]
\also
	Carrier\_Map\_hAC[\genT, \genU] \defs Carrier\_Map[\genT, \genU][h / function, A / domain, C / codomain]
\end{zed}

The carrier map $(g, B, C)$ is said to be \textit{composable} with the carrier map $(f, A, B)$.
\begin{schema}{Carrier\_Composable\_gf[\genT, \genU, \genV]}
	Carrier\_Map\_fAB[\genT, \genU] \\
	Carrier\_Map\_gBC[\genU, \genV]
\end{schema}

Let $carrier\_composable[\genT]$ denote the set of composable pairs of carrier maps in $\genT$.
\begin{zed}
	carrier\_composable[\genT] == \\
	\t1	\{~ Carrier\_Composable\_gf[\genT, \genT, \genT] @ (g, B, C) \mapsto (f, A, B) ~\}
\end{zed}

The carrier map $(h, A, C)$ is said to be the \textit{composition} of $(g, B, C)$ with $(f, A, B)$ when
$h$ is the function composition $g \circ f$.
\begin{schema}{Carrier\_Composition\_hgf}[\genT, \genU, \genV]
	Carrier\_Map\_fAB[\genT, \genU] \\
	Carrier\_Map\_gBC[\genU, \genV] \\
	Carrier\_Map\_hAC[\genT, \genV]
\where
	h = g \circ f
\end{schema}

Let $carrier\_composition[\genT]$ denote the composition operation on composable carrier maps
for structures in $\genT$.
\begin{zed}
	carrier\_composition[\genT] == \\
	\t1	\{~ Carrier\_Composition\_hgf[\genT, \genT, \genT] @ ((g, B, C), (f, A, B)) \mapsto (h, A, C) ~\}
\end{zed}

\section{Magmas}

Let $\genT$ be a set.
A \textit{binary operator} in $\genT$ is a partial function from pairs of elements of $\genT$ to elements of $\genT$.
\begin{zed}
	BINOP[\genT] == \genT \cross \genT \pfun \genT
\end{zed}

Let $elements$ be a subset of $\genT$ and
let $op$ be binary operator defined on all pairs of elements.
We call the structure $(elements, op)$ a \textit{magma on the set} $elements$.
Furthermore, we say that it is a \textit{magma in} $\genT$.
\begin{schema}{Magma}[\genT]
	Carrier[\genT] \\
	op: BINOP[\genT] \\
	structure: \power \genT \cross BINOP[\genT]
\where
	op \in elements \cross elements \fun elements
\also
	structure = (elements, op)
\end{schema}

Let $magma[\genT]$ denote the set of all magmas in $\genT$.
\begin{zed}
	magma[\genT] == \{~ Magma[\genT] @ structure ~\}
\end{zed}

Let the notation $\magma \genT$ denote the set of all magmas in $\genT$.
\begin{zed}
	\magma \genT == magma[\genT]
\end{zed}

Let $integer\_addition$ denote the binary operation of integer addition.
\begin{zed}
	integer\_addition == (\num, (\_ + \_))
\end{zed}

\begin{example}
Integer addition is a magma on $\num$.
\begin{zed}
	integer\_addition \in \magma \num
\end{zed}
\end{example}

Let $integer\_multiplication$ denote the magma of integer multiplication.
\begin{zed}
	integer\_multiplication == (\num, (\_ * \_))
\end{zed}

\begin{example}
Integer multiplication is a magma on $\num$.
\begin{zed}
	integer\_multiplication \in \magma \num
\end{zed}
\end{example}

The result of applying a binary operator to a pair of elements $(x, y)$ 
is normally denoted by an expression formed using an infix operator such as $x + y$ or $x * y$.

Let $\genT$ and $\genU$ be sets, 
let $A \subseteq \genT$ and $B \subseteq \genU$ be subsets of elements,
and let the infix expression $x * y$ denote binary operators on both $A$ and $B$.
Here we follow the standard practice of using visually indistinguishable symbols to denote distinct mathematical
objects when no confusion can occur.
Although the symbols look the same, they are encoded distinctly at the source level,
in this case using the operator names \verb|\mulA| and \verb|\mulB|.
This practice makes the typeset expressions look as close as possible to informal mathematical notation
while at the same time satisfying the strict requirements of the type checker.

Let $Magma\_A$ denote the magma $\strucA$ where $A$ is the set of elements and 
$\_  \mulA \_$ is the infix operator named \verb|\mulA|.
\begin{zed}
	Magma\_A[\genT] \defs \\
	\t1	Magma[\genT][A / elements, \_ \mulA \_ / op, \strucA / structure]
\end{zed}

Similarly, let $Magma\_B$ denote the magma $\strucB$ where $B$ is the set of elements and 
$\_ \mulB \_$ is the infix operator named \verb|\mulB|.
\begin{zed}
	Magma\_B[\genT] \defs \\
	\t1	Magma[\genT][B / elements, \_ \mulB \_ / op, \strucB / structure]
\end{zed}

Let $\strucA$ and $\strucB$ be magmas and let $f$ map $A$ to $B$.
\begin{schema}{Magma\_Map\_AB}[\genT, \genU]
	Magma\_A[\genT] \\
	Magma\_B[\genU] \\
	f: \genT \pfun \genU
\where
	f \in A \fun B
\end{schema}

The map $f$ is said to {\em preserve the operations} if it maps the product of elements of $A$ to 
the product of the mapped elements of $B$.
\begin{schema}{Magma\_MapPreservesOperations\_AB}[\genT, \genU]
	Magma\_Map\_AB[\genT, \genU]
\where
	\forall x, y: A @ \\
	\t1	f(x \mulA y) = (f~x) \mulB (f~y)
\end{schema}

\begin{example}
Multiplication by a fixed integer $c$ maps $\num$ to $\num$ and preserves addition.
\begin{zed}
	\forall c, x, y: \num @ \\
	\t1	c * (x + y) = c * x + c * y
\end{zed}

Therefore
\begin{zed}
	\forall Magma\_Map\_AB[\num, \num]; c: \num | \\
	\t1	\strucA = \strucB = (\num, (\_ +  \_)) \land \\
	\t1	f = (\lambda x: \num @ c * x) @ \\
	\t2		Magma\_MapPreservesOperations\_AB[\num, \num]
\end{zed}
\end{example}

\begin{example}
Exponentiation by a fixed natural number $n$ maps $\num$ to $\num$ and preserves multiplication.
\begin{zed}
	\forall n: \nat; x, y: \num @ \\
	\t1	(x * y) \expN n = x \expN n * y \expN n
\end{zed}
\end{example}

A map that preserves operations is said to be a \textit{magma homomorphism}.

Let $\strucA, \strucB$ be magmas in $\genT$ and $\genU$. 
Let $hom\_magma[\genT, \genU](\strucA, \strucB)$ denote the set of all magma homomorphisms from $\strucA$ to $\strucB$.

\begin{zed}
	hom\_magma[\genT, \genU] == \\
	\t1	(\lambda \alpha: \magma \genT; \beta: \magma \genU @ \\
	\t2		\{~ Magma\_MapPreservesOperations\_AB[\genT, \genU] | \\
	\t3			\alpha = \strucA \land \beta = \strucB @ f ~\})
\end{zed}

\begin{remark}
\begin{zed}
	hom\_magma[\setT, \setU] \in \magma \setT \cross \magma \setU \fun \power (\setT \pfun \setU)
\end{zed}
\end{remark}

Let the notation $\homMagma(\alpha, \beta)$,  typeset using the command \verb|\homBinOp|, 
denote the set of magma homomorphisms from $\alpha$ to $\beta$.

\begin{zed}
	\homMagma[\genT, \genU] == hom\_magma[\genT, \genU]
\end{zed}

\begin{remark}
The identity map preserves all operations.
\begin{zed}
	\forall \strucA: \magma \setX @ \\
	\t1	\id \setX \in \homMagma(\strucA, \strucA)
\end{zed}
\end{remark}

\begin{remark}
The composition of two magma homomorphisms is a magma homomorphism.
\begin{zed}
	\forall \strucA: \magma \setX; \strucB: \magma \setY; \strucC: \magma \setZ @ \\
	\t1	\forall f: \homMagma(\strucA, \strucB); g: \homMagma(\strucB, \strucC) @ \\
	\t2		g \circ f \in \homMagma(\strucA, \strucC)
\end{zed}
\end{remark}

\section{Semigroups}

A magma is said to be \textit{associative} if the result of applying its operation to any three elements
is independent of the order in which it is applied pairwise.

\begin{schema}{Magma\_IsAssociative\_A}[\genT]
	Magma\_A[\genT]
\where
	\forall x, y, z: A @ \\
	\t1	x \mulA y \mulA z = x \mulA (y \mulA z)
\end{schema}

An associative magma is called a \textit{semigroup}.
\begin{zed}
	Semigroup\_A[\genT] \defs Magma\_IsAssociative\_A[\genT]
\end{zed}

Let $semigroup[\genT]$ denote the set of all semigroups in $\genT$.

\begin{zed}
	semigroup[\genT] == \{~ Semigroup\_A[\genT] @ \strucA  ~\}
\end{zed}

Let the notation $\semigroup \genT$, typeset using the prefix generic command \verb|\semigroup|,
denote the set of all semigroups in $\genT$.

\begin{zed}
	\semigroup \genT == semigroup[\genT]
\end{zed}

\begin{remark}
\begin{zed}
	\semigroup \setT \subseteq \magma \setT
\end{zed}
\end{remark}

A \textit{semigroup homomorphism} is a homomorphism of the underlying magma.

Let $\strucA, \strucB$ be semigroups in $\genT, \genU$.
Let $hom\_semigroup(\strucA, \strucB)$ denote the set of semigroup homomorphisms from $\strucA$ to $\strucB$.

\begin{zed}
	hom\_semigroup[\genT, \genU] == \\
	\t1	(\lambda \strucA: \semigroup \genT; \strucB: \semigroup \genU @ \homMagma(\strucA, \strucB))
\end{zed}

Note that as structures, semigroups are a subset of magmas.
Every magma homomorphism of a semigroup is a semigroup homomorphism.

If $\strucA$ is a semigroup, $\strucB$ is a magma, and $f$ is magma homomorphism from 
$\strucA$ to $\strucB$ then the image of $f$ is a semigroup.

Let $\homSemigroup(\strucA, \strucB)$ denote the set of all semigroup homomorphisms from $\strucA$ to $\strucB$.

\begin{gendef}[\genT, \genU]
	\homSemigroup: \semigroup \genT \cross \semigroup \genU \fun \power (\genT \pfun \genU)
\where
	\homSemigroup = \\
	\t1	(\lambda \strucA: \semigroup \genT; \strucB: \semigroup \genU @ \homMagma(\strucA, \strucB))
\end{gendef}

\begin{remark}
The identity mapping is a semigroup homomorphism.
\end{remark}

\begin{remark}
The composition of two semigroup homomorphisms is another semigroup homomorphism.
\end{remark}

\section{Monoids}

Let $\genT$ be a set, let $\strucA = (A, (\_ \mulA \_))$ be a magma in $\genT$, and let $e$ be an element of $A$.
The element $e$ is said to be an \textit{identity element} of $\strucA$ if left and right 
products with it leave all elements unchanged.

\begin{schema}{IdentityElement\_A}[\genT]
	Magma\_A[\genT] \\
	e: \genT
\where
	e \in A
\also
	\forall x: A @ e \mulA x = x = x \mulA e
\end{schema}

Clearly, not all magmas have identity elements.
For example, consider the set of even integers under multiplication.
However, if a magma has an identity element, then it is unique.
This will be proved next.

Let $identity\_element$ denote the relation between magmas and identity elements.
\begin{zed}
	identity\_element[\genT] == \\
	\t1	\{~ IdentityElement\_A[\genT] @ \strucA \mapsto e ~\}
\end{zed}

\begin{remark}
\begin{zed}
	identity\_element[\setT] \in \magma \setT \rel \setT
\end{zed}
\end{remark}

Consider the case of a binary operation $\strucA$ that has, possibly distinct, identity elements $e, e'$.
\begin{schema}{IdentityElements\_A}[\genT]
	Magma\_A[\genT] \\
	e, e': \genT
\where
	\{ \strucA \} \cross \{ e, e' \} \subseteq identity\_element[\genT]
\end{schema}

\begin{remark}
If a magma has an identity element then it is unique.

\begin{zed}
	\forall IdentityElements\_A[\setT] @ e = e'
\end{zed}

\begin{proof}
\begin{argue}
e \\
\t1	= e \mulA e'	& $e'$ is an identity element \\
\t1	= e'			& $e$ is an identity element
\end{argue}
\end{proof}

\end{remark}

\begin{remark}
If an identity element exists then it is unique.
Therefore the relation from magmas to identity elements is a partial function.

\begin{zed}
identity\_element[\setT] \in \magma \setT \pfun \setT
\end{zed}

\end{remark}

Identity elements are typically denoted by the symbols  $\zeroG$ when the operation is thought of as an addition
or $\oneG$ when the operation is thought of as a multiplication.

A {\em monoid} in $\genT$ is a semigroup in $\genT$ that has an identity element.
\begin{schema}{Monoid\_A}[\genT]
	Semigroup\_A[\genT] \\
	IdentityElement\_A[\genT]
\end{schema}

Let $\monoid \genT$ denote the set of all monoids in $\genT$.
\begin{zed}
	\monoid \genT == \{~ Monoid\_A[\genT] @ \strucA ~\}
\end{zed}


Let $\strucA$ and $\strucB$ be monoids and let $f$ map the elements of $A$ to the elements of $B$.
The map $f$ is said to {\em preserve the identity element} if it maps the identity element of $A$
to the identity element of $B$.
\begin{schema}{MapPreservesIdentity}[\genT, \genU]
	f: \genT \pfun \genU \\
	\strucA: \monoid \genT \\
	\strucB: \monoid \genU
\where
\LET e == identity\_element~\strucA; \\
\t1	e' == identity\_element~\strucB @ \\
\t2		f~e = e'
\end{schema}

A {\em monoid homomorphism} from $\strucA$ to $\strucB$ is a homomorphism $f$ of the underlying semigroups
that preserves identity.
Let $\homMonoid(\strucA, \strucB)$ denote the set of all monoid homomorphisms from $\strucA$ to $\strucB$.
\begin{gendef}[\genT, \genU]
	\homMonoid: \monoid \genT \cross \monoid \genU \fun \power (\genT \fun \genU)
\where
	\homMonoid = \\
	\t1	(\lambda \strucA: \monoid \genT; \strucB: \monoid \genU @ \\
	\t2		\{~ f: \homSemigroup(\strucA, \strucB) | \\
	\t3			MapPreservesIdentity[\genT, \genU] ~\})
\end{gendef}

\begin{remark}
The identity mapping is a monoid homomorphism.
\end{remark}

\begin{remark}
The composition of two monoid homomorphisms is another monoid homomorphism.
\end{remark}

\section{Groups}

Let $\strucA$ be a monoid in $\genT$.
A function $inv \in A \fun A$ is said to be an \textit{inverse operation} if it maps each element
to an element whose product with it is the identity element.
Typically, the postfix expression $x \invG$ is used to denote the inverse of $x$.

\begin{schema}{InverseOperation\_A}[\genT]
	Monoid\_A[\genT] \\
	inv: \genT \pfun \genT
\where
	inv \in A \fun A
\also
	\LET (\_ \invG) == inv @ \\
	\t1	\forall x: A @ \\
	\t2		x \mulA x \invG = e = x \invG  \mulA x
\end{schema}

Let $inverse\_operation$ denote the relation between monoids and their inverse operations.
\begin{zed}
	inverse\_operation[\genT] == \\
	\t1	\{~ InverseOperation\_A[\genT] @ \strucA \mapsto inv ~\}
\end{zed}

\begin{remark}
If a monoid has an inverse operation then it is unique.
\end{remark}

\begin{proof}
Let $x$ be any element.
Suppose $x \invG$ and $x \daggerG$ are inverses of $x$.
\begin{argue}
x\daggerG \\
\t1	= x\daggerG \mulG \oneG				& $\oneG$ is an identity element \\
\t1	= x\daggerG \mulG (x \mulG x \invG)		& $x \invG$ is an inverse \\
\t1	= (x\daggerG \mulG x) \mulG x \invG		& associativity \\
\t1	= \oneG \mulG x \invG				& $x \daggerG$ is an inverse \\
\t1	= x \invG							& $\oneG$ is an identity element
\end{argue}
\end{proof}

\begin{remark}
Since inverse operations are unique if exist they, the relation between monoids and inverse operations
is a partial function.

\begin{zed}
	inverse\_operation \in \monoid \setT \pfun \setT \pfun \setT
\end{zed}

\end{remark}

A {\em group} is a monoid that has an inverse operation.
\begin{schema}{Group\_A}[\genT]
	InverseOperation\_A[\genT]
\end{schema}

Let $\genT$ be a set of elements.
Let $\group \genT$ denote the set of all groups over $\genT$.
\begin{zed}
	\group \genT == \{~ Group\_A[\genT] @ \strucA ~\}
\end{zed}

Let $\genT$ and $\genU$ be sets of elements,
let $\strucA$ and $\strucB$ be groups over $\genT$ and $\genU$, 
and let $f$ map $\genT$ to $\genU$.
The map $f$ is said to {\em preserve the inverses} if it maps the inverses of elements of $A$
to the inverses of the corresponding elements of $B$.
\begin{schema}{MapPreservesInverse}[\genT, \genU]
	f: \genT \pfun \genU \\
	\strucA: \group \genT \\	
	\strucB: \group \genU
\where
	\LET (\_ \invG) == inverse\_operation~\strucA; \\
	\t1	(\_ \daggerG) == inverse\_operation~\strucB @ \\
	\t2		\forall x: \genT @ \\
	\t3			f(x \invG) = (f~x) \daggerG
\end{schema}

Let $\strucA$ and $\strucB$ be groups.
A {\em group homomorphism} from $\strucA$ to $\strucB$ is a monoid homomorphism
from $\strucA$ to $\strucB$ that preserves inverses.
Let $\homGroup(\strucA, \strucB)$ denote the set of all group homomorphisms from $\strucA$ to $\strucB$.
\begin{gendef}[\genT, \genU]
	\homGroup: \group \genT \cross \group \genU \fun \power (\genT \fun \genU)
\where
	\homGroup = \\
	\t1	(\lambda \strucA: \group \genT; \strucB: \group \genU @ \\
	\t2		\{~ f: \homMonoid(\strucA, \strucB) | \\
	\t3			MapPreservesInverse[\genT, \genU] ~\})
\end{gendef}

\begin{remark}
The identity mapping is a group homomorphism.
\end{remark}

\begin{remark}
The composition of two group homomorphisms is another group homomorphism.
\end{remark}

\subsection{Bijections}

Let $\genT$ be a set and let $bij[\genT]$ denote the set of a bijections $\genT \bij \genT$ from $\genT$ to itself.
\begin{zed}
	bij[\genT] == \genT \bij \genT
\end{zed}

\begin{remark}
The composition of bijections is a bijection.

\begin{zed}
	\forall f, g: bij[\setT] @ \\
	\t1	f \circ g \in bij[\setT]
\end{zed}

\end{remark}

\begin{remark}
Composition is associative.

\begin{zed}
	\forall f, g, h: bij[\setT] @ \\
	\t1	f \circ (g \circ h) = (f \circ g) \circ h
\end{zed}

\end{remark}

\begin{remark}
The identity function $\id \setT$ acts as a left and right identity element under composition.

\begin{zed}
	\forall f: bij[\setT] @ \\
	\t1	 \id \setT \circ f = f = f \circ \id \setT
\end{zed}

\end{remark}

\begin{remark}
The inverse $f \inv$ of a bijection $f$ is its left and right inverse under composition.

\begin{zed}
	\forall f: bij[\setT] @ \\
	\t1	f \circ f \inv = \id \setT = f \inv \circ f
\end{zed}

\end{remark}

The preceding remarks show that set $bij[\genT]$ under the operation of composition has the structure of a group.
Let $Bij[\genT]$ denote the composition of bijections.
\begin{zed}
	Bij[\genT] == (\lambda f, g: bij[\genT] @ f \circ g)
\end{zed}

\begin{example}
Let $\setT$ be any set.
The composition of bijections of $\setT$ is a group.

\begin{zed}
(bij[\setT], Bij[\setT]) \in \group bij[\setT]
\end{zed}

\end{example}

\section{Abelian Groups}

A magma $\strucA$ in $\genT$ is said to be {\em commutative} when the product of two elements doesn't depend on 
their order.
\begin{schema}{OperationIsCommutative\_A}[\genT]
	Magma\_A[\genT]
\where
	\forall x, y: A @ x \mulA y = y \mulA x
\end{schema}

An {\em abelian group} is a group in which the binary operation is commutative.
\begin{schema}{AbelianGroup\_A}[\genT]
	Group\_A[\genT] \\
	OperationIsCommutative\_A[\genT]
\end{schema}

Let $\abgroup \genT$ denote the set of all abelian groups in $\genT$.
\begin{zed}
	\abgroup \genT == \{~ AbelianGroup\_A[\genT] @ \strucA ~\}
\end{zed}

Often in an abelian group the binary operation is denoted as addition $x \addG y$,
the identity element as a zero $\zeroG$, and the inverse operation as negation $\negG x$.

\begin{example}
Addition over the integers is an abelian group.

\begin{zed}
	(\num, (\_ + \_)) \in \abgroup \num
\end{zed}

\end{example}

\printbibliography

\end{document}\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{mathz_real_numbers}[2018/08/05 Z Notation for real numbers package]

\RequirePackage{amssymb}

% real numbers

% the set of real numbers
\newcommand{\R}{\mathbb{R}}

% the real number 0
\newcommand{\zeroR}{0}

% the real number 1
\newcommand{\oneR}{1}

% the real number 2
\newcommand{\twoR}{2}

% the negation prefix operator -x
\DeclareMathOperator{\negR}{-}

% the set of nonzero real numbers
\newcommand{\Rnz}{\R_{*}}

% the set of positive real numbers
\newcommand{\Rpos}{\R_{+}}

% the set of negative real numbers
\newcommand{\Rneg}{\R_{-}}

% the set of less than zero real numbers
\newcommand{\Rltz}{\R_{< 0}}

% the set of less than or equal to zero real numbers
\newcommand{\Rlez}{\R_{\leq 0}}

% the set of greater than or equal to zero real numbers
\newcommand{\Rgez}{\R_{\geq 0}}

% the set of greater than zero real numbers
\newcommand{\Rgtz}{\R_{> 0}}

% the addition infix operator x + y
%%inop \addR 3
\newcommand{\addR}{\mathbin{+}}

% the subtraction infix operator x - y
%%inop \subR 3
\newcommand{\subR}{\mathbin{-}}

% the multiplication infix operator x * y
%%inop \mulR 4
\newcommand{\mulR}{\mathbin{*}}

% the division infix operator x / y
%%inop \divR 4
\newcommand{\divR}{\mathbin{/}}

% the multiplication infix operator restricted to non-zero real numbers
%%inop \mulRnz 4
\newcommand{\mulRnz}{\mathbin{*}}

% the inverse postfix operator defined on non-zero real numbers
%%postop \invRnz
\newcommand{\invRnz}{^{-1}}

% the less than infix relation x < y
%%inrel \ltR
\newcommand{\ltR}{\mathrel{<}}

% the less than or equal to infix relation x <= y
%%inrel \leR
\newcommand{\leR}{\mathrel{\leq}}

% the greater than infix relation x > y
%%inrel \gtR
\newcommand{\gtR}{\mathrel{>}}

% the greater than or equal to infix relation x > y
%%inrel \geR
\newcommand{\geR}{\mathrel{\geq}}

% sum of a sequence of real numbers
\newcommand{\sumR}{\Sigma}

% the set of all open sets of real numbers
\newcommand{\openR}{\mathsf{open}}

% the absolute value function abs(x) = |x|
\DeclareMathOperator{\absR}{abs}

% the positive square root function sqrt(x)
\DeclareMathOperator{\sqrtR}{sqrt}

\DeclareMathOperator{\intervalR}{interval}
\DeclareMathOperator{\ballR}{ball}
\DeclareMathOperator{\ballsR}{balls}
\DeclareMathOperator{\neighR}{neigh}

\newcommand{\tauR}{\tau_\R}
\newcommand{\Rtau}{\R_\tau}

\DeclareMathOperator{\limRR}{lim}
\DeclareMathOperator{\limR}{lim}
\DeclareMathOperator{\limFR}{lim}

\DeclareMathOperator{\FunR}{F}
\DeclareMathOperator{\FunPR}{F}

\DeclareMathOperator{\CzeroR}{C^0}
\DeclareMathOperator{\CzeroPR}{C^0}

\DeclareMathOperator{\CnR}{C}
\DeclareMathOperator{\CnPR}{C}

\DeclareMathOperator{\diffRR}{diff}
\DeclareMathOperator{\diffR}{diff}
\DeclareMathOperator{\diffPR}{diff}

\DeclareMathOperator{\smoothR}{C^{\infty}}
\DeclareMathOperator{\smoothPR}{C^{\infty}}

\DeclareMathOperator{\derivFR}{D}
\DeclareMathOperator{\derivF}{D}

\DeclareMathOperator{\asZR}{\mathsf{real}}

\DeclareMathOperator{\sinR}{sin}
\DeclareMathOperator{\cosR}{cos}
\DeclareMathOperator{\tanR}{tan}
\DeclareMathOperator{\expR}{exp}
\DeclareMathOperator{\logR}{log}
\newcommand{\piR}{\pi}

% the multiplication infix operator x * y for integers times reals
%%inop \mulZR 4
\newcommand{\mulZR}{\mathbin{*}}

% the division infix operator x / y for reals divided by integers
%%inop \divRZ 4
\newcommand{\divRZ}{\mathbin{/}}

% the real plane
\newcommand{\Rtwo}{\R^2}

% the origin of the real plane
\newcommand{\zeroRtwo}{\mathbf{0}}

% addition of points in the real plane
%%inop \addRtwo 3
\newcommand{\addRtwo}{\mathbin{+}}

% scalar multiplication of points in the real plane
%%inop \smulRtwo 4
\newcommand{\smulRtwo}{\mathbin{*}}

% scalar multiplication of points in the real plane by an integer
%%inop \smulZRtwo 4
\newcommand{\smulZRtwo}{\mathbin{*}}

% sum of a sequence of points in the real plane
\newcommand{\sumRtwo}{\Sigma}

% addition of functions to the real plane
%%inop \addFRtwo 3
\newcommand{\addFRtwo}{\mathbin{+}}

% the real 3-space
\newcommand{\Rthree}{\R^3}

% dot product of points in the real plane
%%inop \dotRtwo 4
\newcommand{\dotRtwo}{\mathbin{\cdot}}

% the norm of a point in the real plane
\DeclareMathOperator{\normRtwo}{norm}

% the unit sphere in the real plane
\newcommand{\sphereOne}{S^1}

% the unit sphere in real space
\newcommand{\sphereTwo}{S^2}
