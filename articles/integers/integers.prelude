%
% fuzzlib.x
%
% This file is part of fuzz2000
% Copyright (c) 1982--2006 J. M. Spivey
% All rights reserved
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
% 1. Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
% 2. Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
% 3. The name of the author may not be used to endorse or promote products
%    derived from this software without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
% IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
% OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
% IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
% SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
% PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
% OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
% WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
% OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
% ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
% 
% $Id: fuzzlib.x,v 1.2 2007-02-16 12:45:13 mike Exp $
%

%%token $"\bind" 335
%%token $"\bsup" 262
%%token $"\cross" 266
%%token $"\defs" 268
%%token $"\ELSE" 333
%%token $"\esup" 275
%%token $"\exists" 277
%%token $"\exists_1" 278
%%token $"false" 280
%%token $"\forall" 282
%%token $"\hide" 284
%%token $"\iff" 273
%%token $"\IF" 331
%%token $"\implies" 285
%%token $"\in" 286
%%token $"\inrel" 329
%%token $"\lambda" 289
%%token $"\land" 258
%%token $"\langle" 334
%%token $"\lbag" 290
%%token $"\ldata" 291
%%token $"\LET" 292
%%token $"\limg" 293
%%token $"\lnot" 296
%%token $"\lor" 298
%%token $"\mid" 124
%%token $"\mu" 294
%%token $"\pipe" 299
%%token $"\power" 300
%%token $"\pre" 301
%%token $"\project" 302
%%token $"\rangle" 336
%%token $"\rbag" 303
%%token $"\rdata" 304
%%token $"\rimg" 305
%%token $"\semi" 281
%%token $"\spot" 64
%%token $"\THEN" 332
%%token $"\theta" 306
%%token $"true" 307
%%token $"\vdash" 309
%%token $"\where" 310
%%token $"==" 272
%%token $"%%ingen" 312
%%token $"%%inop" 313
%%token $"%%inrel" 314
%%token $"%%pregen" 316
%%token $"%%prerel" 317
%%token $"%%postop" 315
%%token $"%%type" 318
%%token $"%%tame" 319
%%token $"%%pname" 320
%%token $"%%ignore" 338
%%token $"%%debug" 340
%%token $"%%line" 341
%%token $"\begin{axdef}" 259
%%token $"\begin{gendef}" 260
%%token $"\begin{schema}" 261
%%token $"\begin{zed}" 264
%%token $"\begin{syntax}" 263
%%token $"\end{axdef}" 270
%%token $"\end{gendef}" 271
%%token $"\end{schema}" 274
%%token $"\end{zed}" 279
%%token $"\end{syntax}" 276

%%inop \mapsto							1
%%inop \upto							2
%%inop + - \cup \setminus \cat \uplus \uminus			3
%%inop * \div \mod \cap \circ \comp \filter \extract \otimes	4
%%inop \oplus \bcount						5
%%inop \dres \rres \ndres \nrres				6
%%postop \plus \star \inv
%%inrel \neq \notin \subseteq \subset < \leq \geq > \inbag \partition
%%inrel \prefix \subbageq \suffix \inseq
%%prerel \disjoint
%%ingen \rel \fun \pinj \inj \psurj \surj \bij \ffun \finj
%%pregen \power_1 \id \finset \iseq
%%ignore \quad \qquad

%%type \pfun \nat \seq \bag
\begin{gendef}[X]
	\finset \_: \power (\power X)
\end{gendef}
\begin{gendef}[X,Y]
	\_ \rel \_, \_ \ffun \_: \power (\power (X \cross Y)) \\
	\_ \fun \_: \power (X \pfun Y)
\end{gendef}
%%type \rel \ffun \finset

\begin{axdef}
	-: \num \fun \num \\
        \_ + \_ , \_ - \_ , \_ * \_: \num \cross \num \fun \num \\
        \_ \div \_ , \_ \mod \_: 
		\num \cross \num \pfun \num \\
        \_ < \_ , \_ \leq \_ , \_ \geq \_ , \_ > \_: 
		\num \rel \num \\
	\nat_1: \power \nat \\
        succ: \nat \fun \nat \\
	\_ \upto \_: \num \cross \num \fun \power \num \\
        min: \power \num \pfun \num \\
        max: \power \num \pfun \num
\end{axdef}

\begin{gendef}[X]
        \_ \neq \_: X \rel X \\
        \_ \notin \_: X \rel \power X \\
	\empty, \emptyset: \power X \\
	\_ \subseteq \_ , \_ \subset \_: \power X \rel \power X \\
	\power_1 \_: \power (\power X) \\
        \_  \cup \_ , \_ \cap \_ , \_ \setminus \_:
                \power X \cross \power X \fun \power X \\
        \bigcup, \bigcap: \power (\power X) \fun \power X \\
	\id \_: X \rel X \\
        \_\plus, \_\star: (X \rel X) \fun (X \rel X) \\
        iter: \num \fun (X \rel X) \fun (X \rel X) \\
	\finset_1 \_: \power (\finset X) \\
        \#: \finset X \fun \nat \\
	\seq_1 \_, \iseq \_: \power (\seq X) \\
        \_ \cat \_ :  \seq X \cross \seq X \fun \seq X \\
        head, last: \seq X \pfun X \\
        tail, front: \seq X \pfun \seq X \\
        rev: \seq X \fun \seq X \\
        \_ \filter \_: \seq X \cross \power X \fun \seq X \\
        \_ \extract \_: \power \nat \cross \seq X \pfun \seq X \\
	squash: (\nat \ffun X) \pfun \seq X \\
	\_\prefix\_, \_\suffix\_, \_\inseq\_: \seq X \rel \seq X \\
        \dcat: \seq (\seq X) \fun \seq X \\
        count: \bag X \fun (X \fun \nat) \\
	\_\bcount\_: \bag X \cross X \fun \nat \\
        \_ \inbag \_: X \rel \bag X \\
	\_ \subbageq \_: \bag X \rel \bag X \\
        \_ \uplus \_, \_ \uminus \_: \bag X \cross \bag X \fun \bag X \\
	\_ \otimes \_: \nat \cross \bag X \fun \bag X \\
        items: \seq X \fun \bag X
\end{gendef}

\begin{gendef}[X,Y]
        first: X \cross Y \fun X \\
        second: X \cross Y \fun Y \\
        \_ \mapsto \_: X \cross Y \fun X \cross Y \\
        \dom: (X \rel Y) \fun \power X \\
        \ran: (X \rel Y) \fun \power Y \\
        \_ \dres \_: \power X \cross (X \rel Y) \fun (X \rel Y) \\
        \_ \rres \_: (X \rel Y) \cross \power Y \fun (X \rel Y) \\
        \_ \ndres \_: \power X \cross (X \rel Y) \fun (X \rel Y) \\
        \_ \nrres \_: (X \rel Y) \cross \power Y \fun (X \rel Y) \\
        \_\inv: (X \rel Y) \fun (Y \rel X) \\
        \_\limg\_\rimg: (X \rel Y) \cross \power X \fun \power Y \\
        \_ \oplus \_: (X \rel Y) \cross (X \rel Y) \fun (X \rel Y) \\
	\_ \pinj \_, \_ \inj \_, \_ \psurj \_, 
	\_ \surj \_, \_ \bij \_, \_ \finj \_: \power(X \pfun Y) \\
        \disjoint \_: \power (X \pfun \power Y) \\
        \_ \partition \_: (X \pfun \power Y) \rel \power Y
\end{gendef}

\begin{gendef}[X,Y,Z]
        \_ \comp \_: (X \rel Y) \cross (Y \rel Z) \fun (X \rel Z) \\
	\_ \circ \_: (Y \rel Z) \cross (X \rel Y) \fun (X \rel Z)
\end{gendef}

%%pname \pfun $"-+>"
%%pname \ffun $"-++>"
%%pname \rel $"<->"
%%pname \seq $"seq"
%%pname \bag $"bag"
%%pname \finset $"F"
%%pname \nat $"NN"
%%pname \num $"ZZ"
%%pname \upto $".."
%%pname \# $"#"
%%pname \power_1 $"P_1"
%%pname \id $"id"
%%pname \mapsto $"|->"
%%pname \dom $"dom"
%%pname \ran $"ran"
%%pname \fun $"-->"
%%pname \pinj $">+>"
%%pname \inj $">->"
%%pname \psurj $"-+>>"
%%pname \surj $"-->>"
%%pname \bij $">->>"
%%pname \finj $">++>"
%%pname \disjoint $"disjoint"
%%pname \partition $"partition"

%%tame \cup \cap \setminus \bigcup \bigcap count \uplus items
%%tame \plus \cat head last tail front rev \filter \dcat
%%tame first second \mapsto \dom \ran \dres \rres \ndres \nrres 
%%tame \inv \limg\rimg \oplus \comp \circ
% style file for sets.tex

% formal parameters for generic constructions
\newcommand{\genA}{\mathsf{a}}
\newcommand{\genB}{\mathsf{b}}
\newcommand{\genC}{\mathsf{c}}
\newcommand{\genD}{\mathsf{d}}
\newcommand{\genE}{\mathsf{e}}
\newcommand{\genF}{\mathsf{f}}
\newcommand{\genG}{\mathsf{g}}
\newcommand{\genH}{\mathsf{h}}
\newcommand{\genI}{\mathsf{i}}
\newcommand{\genJ}{\mathsf{j}}
\newcommand{\genK}{\mathsf{k}}
\newcommand{\genL}{\mathsf{l}}
\newcommand{\genM}{\mathsf{m}}
\newcommand{\genN}{\mathsf{n}}
\newcommand{\genO}{\mathsf{o}}
\newcommand{\genP}{\mathsf{p}}
\newcommand{\genQ}{\mathsf{q}}
\newcommand{\genR}{\mathsf{r}}
\newcommand{\genS}{\mathsf{s}}
\newcommand{\genT}{\mathsf{t}}
\newcommand{\genU}{\mathsf{u}}
\newcommand{\genV}{\mathsf{v}}
\newcommand{\genW}{\mathsf{w}}
\newcommand{\genX}{\mathsf{x}}
\newcommand{\genY}{\mathsf{y}}
\newcommand{\genZ}{\mathsf{z}}

% arbitrary sets used in theorems, remarks, and examples involving generic constructs
\newcommand{\setA}{\mathsf{A}}
\newcommand{\setB}{\mathsf{B}}
\newcommand{\setC}{\mathsf{C}}
\newcommand{\setD}{\mathsf{D}}
\newcommand{\setE}{\mathsf{E}}
\newcommand{\setF}{\mathsf{F}}
\newcommand{\setG}{\mathsf{G}}
\newcommand{\setH}{\mathsf{H}}
\newcommand{\setI}{\mathsf{I}}
\newcommand{\setJ}{\mathsf{J}}
\newcommand{\setK}{\mathsf{K}}
\newcommand{\setL}{\mathsf{L}}
\newcommand{\setM}{\mathsf{M}}
\newcommand{\setN}{\mathsf{N}}
\newcommand{\setO}{\mathsf{O}}
\newcommand{\setP}{\mathsf{P}}
\newcommand{\setQ}{\mathsf{Q}}
\newcommand{\setR}{\mathsf{R}}
\newcommand{\setS}{\mathsf{S}}
\newcommand{\setT}{\mathsf{T}}
\newcommand{\setU}{\mathsf{U}}
\newcommand{\setV}{\mathsf{V}}
\newcommand{\setW}{\mathsf{W}}
\newcommand{\setX}{\mathsf{X}}
\newcommand{\setY}{\mathsf{Y}}
\newcommand{\setZ}{\mathsf{Z}}

% families of sets
%%pregen \Fam
\DeclareMathOperator{\Fam}{\mathcal{F}}

% the induced family infix operator
%%inop \inducedFam 6
\newcommand{\inducedFam}{\mathbin{|_\family}}

% the product family infix operator
%%inop \prodFam 5
\newcommand{\prodFam}{\mathbin{\cross_\family}}

% the constant function
\DeclareMathOperator{\const}{const}

% the function restriction infix operator
%%inop \restrictU 6
\newcommand{\restrictU}{\mathbin{|}}

% the set of binary digits
\newcommand{\B}{\mathbb{B}}

% the indicator function of a set
%%pregen \indF
\DeclareMathOperator{\indF}{\mathbf{1}}
\documentclass{amsart}

\usepackage{sets}

\usepackage{biblatex}
\addbibresource{../../shared/references.bib}
\usepackage{parskip}
\usepackage{preamble}

\begin{document}

\title{Sets}
\author{Arthur Ryman}
\email[Arthur Ryman]{arthur.ryman@gmail.com}
\date{\today}

\begin{abstract}
This article contains \ZN\ definitions for 
concepts related to sets.
It has been type checked by \fuzz.
\end{abstract}

\maketitle

\tableofcontents

\section{Introduction}

Typed set theory forms the mathematical foundation of \ZN\
and many set theory concepts are defined in its built-in mathematical toolkit. 
This articles augments the toolkit with some additional concepts.

\section{Binary Digits}

Let $bit$ denote the set of \textit{binary digits}, namely the set $\{ 0, 1\} \subseteq \num$.

\begin{zed}
	bit == \{ 0, 1 \}
\end{zed}

We introduce the notation $\B = bit$.

\begin{zed}
	\B == bit
\end{zed}

\section{Arbitrary Sets}

\ZN\ supports generic constructions which take arbitrary sets as parameters.
It is often of interest to state theorems, remarks, and examples about generic constructions that hold for arbitrary sets.
However, \ZN\ does not allow universal quantification over the set of all sets since this leads to the Russell paradox.
In fact, typed set theory was motivated by a desire to avoid the Russell paradox.

As a workaround, we adopt the convention of stating theorems, remarks, and example that hold for arbitrary sets in terms
of predefined given sets with the understanding that these sets are completely unconstrained by additional axioms.

It is an error to use any of these predefined sets outside of the statement of a theorem, remark, or example.

Let $\setA, \setB, \dots \setZ$ denote these predefined arbitrary sets.

\begin{zed}
	[\setA, \setB, \setC, \setD, \setE, \setF, \setG, \setH, \setI, \setJ, \setK, \setL, \setM, 
	\setN, \setO, \setP, \setQ, \setR, \setS, \setT, \setU, \setV, \setW, \setX, \setY, \setZ]
\end{zed}

For example, consider the following statement which holds for arbitrary sets $\setX$.

\begin{remark}
Equality is reflexive.
\begin{zed}
	\forall x: \setX @ x = x
\end{zed}
\end{remark}

\section{Formal Generic Parameters}

Formal generic parameters appear in the definition of generic schemas and constants where
they are used as placeholders for arbitrary sets.
As a purely stylistic convention, we use the following typographically distinctive symbols as formal generic parameters:
\begin{equation*}
	\genA, \genB, \dots, \genZ
\end{equation*}

\section{Families of Subsets}

Let $\genT$ be a set.
A \textit{family} of subsets of $\genT$ is a set of subsets of $\genT$.
Let $Fam[\genT]$ denote the set of all families of subsets of $\genT$.

\begin{zed}
	Fam[\genT] == \power(\power \genT)
\end{zed}

\begin{example}
The set consisting of the empty set and $\setX$ is a family of subsets of $\setX$.
\begin{zed}
	\{ \emptyset, \setX \} \in Fam[\setX]
\end{zed}
\end{example}

Let the prefix generic symbol $\Fam \genT$ denote the family of subsets of $\genT$ .

\begin{zed}
	\Fam \genT == Fam[\genT]
\end{zed}

\section{Functions}

\subsection{Constant Functions}

Let $\genT$ and $\genU$ be sets and let $c \in \genU$ be some given element.
The mapping $f(x) = c$ that sends every element $x \in \genT$ to $c$ is called the \textit{constant function} on $\genT$ with value $c$.

\begin{schema}{ConstantFunction}[\genT, \genU]
	c: \genU \\
	f: \genT \fun \genU
\where
	f = (\lambda x: \genT @ c)
\end{schema}

Let the function $constant\_function~c = f$ denote the constant function $f: \genT \fun \genU$ with value $c$.

\begin{zed}
	constant\_function[\genT, \genU] == \{~ConstantFunction[\genT, \genU] @ c \mapsto f ~\}
\end{zed}

\begin{remark}
The mapping $constant\_function$ maps each element $c \in \setU$ to a function $\setT \fun \setU$.
\begin{zed}
	constant\_function[\setT, \setU] \in \setU \fun (\setT \fun \setU)
\end{zed}
\end{remark}

Let the notation $\const c$ denote the constant function defined by $c$.

\begin{zed}
	\const[\genT, \genU] == constant\_function[\genT, \genU]
\end{zed}

\begin{remark}
\begin{zed}
	\forall c: \setU; x: \setT @ \const[\setT, \setU] c~x = c
\end{zed}
\end{remark}

\subsection{Function Restriction}

Let $\genT$ and $\genU$ be sets, let $f: \genT \fun \genU$, and let $T \subseteq \genT$ be a subset.
Let $g$ denote the restriction of $f$ to $T$.

\begin{schema}{FunctionRestriction}[\genT, \genU]
	f: \genT \fun \genU \\
	T: \power \genT \\
	g: \genT \pfun \genU
\where
	g = T \dres f
\end{schema}

Let the function  $g = restriction(f, T)$ denote the restriction of $f$ to $T$.

\begin{zed}
	restriction[\genT, \genU] == \{~ FunctionRestriction[\genT, \genU] @ (f, T) \mapsto g ~\}
\end{zed}

Let the generic infix operator $f \restrictU T$ denote the restriction of $f$ to $T$.

\begin{zed}
	(\_ \restrictU \_)[\genT, \genU] == restriction[\genT, \genU]
\end{zed}

\begin{remark}
Function restriction is domain restriction with arguments reversed.
\begin{zed}
	\forall FunctionRestriction[\setT, \setU] @ \\
	\t1	f \restrictU T = T \dres f
\end{zed}
\end{remark}

\subsection{Indicator Functions}

Let $\genT$ be a set and let $X \subseteq \genT$ be a subset.
The \textit{indicator function}  $f$  of $X$ maps each element $a \in \genT$ to 1 if $a \in X$ and 0 otherwise.
The indicator function is also referred to as the \textit{characteristic function} of $X$.

\begin{schema}{IndicatorFunction}[\genT]
	X: \power \genT \\
	f: \genT \fun \B
\where
	f = (\lambda a: \genT @ \IF a \in X \THEN 1 \ELSE 0)
\end{schema}

Let $indicator\_function~X = f$ denote the indicator function of $X$.

\begin{zed}
	indicator\_function[\genT] == \{~ IndicatorFunction[\genT] @ X \mapsto f ~\}
\end{zed}

\begin{remark}
For each subset $X \subseteq \setT$, the indicator function of $X$ is a binary function on $\setT$.
\begin{zed}
	indicator\_function[\setT] \in \power \setT \fun \setT \fun \B
\end{zed}
\end{remark}

We introduce the prefix generic symbol $(\indF \_)$ where $(\indF \genT)X = indicator\_function[\genT] X$.

\begin{zed}
	\indF \genT == indicator\_function[\genT]
\end{zed}

\begin{remark}
The domain of the range restriction of the indicator function of a set $X$ to the range $\{1\}$ is $X$.
\begin{zed}
	\forall X: \power \setT @ \\
	\t1	\dom((\indF \setT)X \rres \{1\}) = X
\end{zed}
\end{remark}

\section{The Support of a Function}

Let $\genT$ be a set and let $f: \genT \fun \num$ be an integer-valued function.
The \textit{support} $S$ of $f$ is the set of elements $x \in \genT$ where $f~x \neq 0$.

\begin{schema}{FunctionSupport}[\genT]
	f: \genT \fun \num \\
	S: \power \genT
\where
	S = \{~ x: \genT | f~x \neq 0 ~\}
\end{schema}

Let the function $S = support~f$ denote the support of $f$.

\begin{zed}
	support[\genT] == \{~ FunctionSupport[\genT] @ f \mapsto S ~\}
\end{zed}

\begin{example}
The support of the indicator function of a set $X$ is $X$.
\begin{zed}
	\forall X: \power \setT @ \\
	\t1 support((\indF \setT)X) = X
\end{zed}
\end{example}

An integer-valued function is said to have \textit{finite support} if its support is a finite set.

\begin{schema}{FiniteSupport}[\genT]
	FunctionSupport[\genT]
\where
	S \in \finset \genT
\end{schema}

Let $finite\_support[\genT]$ denote the set of all integer-valued functions on $\genT$ that have finite support.

\begin{zed}
	finite\_support[\genT] == \{~ FiniteSupport[\genT] @ f ~\}
\end{zed}

\begin{remark}
\begin{zed}
	finite\_support[\setT] \subseteq \setT \fun \num
\end{zed}
\end{remark}

\printbibliography

\end{document}% groups

% binary operations
%%pregen \binop
\DeclareMathOperator{\binop}{binop}

% binary operation homomorphisms
\DeclareMathOperator{\homBinOp}{hom_{op}}

% semigroups

% the set of all semigroups
%%pregen \semigroup
\DeclareMathOperator{\semigroup}{semigroup}

\DeclareMathOperator{\homSemigroup}{hom_{sg}}

% monoids

% the set of all monoids
%%pregen \monoid
\DeclareMathOperator{\monoid}{monoid}
\DeclareMathOperator{\homMonoid}{hom_{mon}}

% groups

%%pregen \group
\DeclareMathOperator{\group}{group}

\DeclareMathOperator{\homGroup}{hom_{grp}}

% group identity element
\newcommand{\oneG}{1}

%%inop \mulG \timesG 4
\newcommand{\mulG}{\mathbin{*}}
\newcommand{\timesG}{\mathbin{\times}}

%%postop \invG \daggerG
\newcommand{\invG}{^{-1}}
\newcommand{\daggerG}{^{\dagger}}

% Abelian groups

%%pregen \abgroup
\DeclareMathOperator{\abgroup}{abgroup}

%%inop \addG 3
\newcommand{\addG}{\mathbin{+}}

\newcommand{\zeroG}{0}

\DeclareMathOperator{\negG}{-}
\documentclass[11pt, oneside]{article}

\usepackage{preamble}
\addbibresource{references.bib}

\usepackage{sets}
\usepackage{groups}

\title{Groups}
\author{Arthur Ryman, {\tt arthur.ryman@gmail.com}}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This article contains Z Notation type declarations for groups and some related objects.
It has been type checked by \fuzz.
\end{abstract}

\tableofcontents

\section{Introduction}

Groups are ubiquitous throughout mathematics and physics.
This article defines the basic algebraic objects related to groups and their homomorphisms.

\section{Binary Operations}

Let $\genT$ be a set. We refer to the members of $\genT$ as its {\em elements}.
A {\em binary operation} on $\genT$ is a function that maps pairs of elements to elements.

\subsection{\zcmd{binop}}

Let $\binop \genT$ denote the set of all binary operations on $\genT$.

\begin{zed}
\binop \genT == \genT \cross \genT \fun \genT
\end{zed}

\subsection{Infix Operator Symbols \zcmd{timesG}, \zcmd{mulG}, and \zcmd{addG}}

The result of applying a binary operation to the pair of elements $(x, y)$ 
is often denoted by an expression formed using an infix operator symbol,
e.g. $x \timesG y$, $x \mulG y$ or $x \addG y$.

\subsection{$MapPerservesOperation$}

Let $\genT$ and $\genU$ be sets and let $A$ and $B$ be binary operations on them.
Let $f$ be a function that maps $\genT$ to $\genU$.
The function $f$ is said to {\em preserve the operations} if it maps the product of elements to 
the product of the mapped elements.

Let $MapPreservesOperation$ denote this situation.

\begin{schema}{MapPreservesOperation}[\genT, \genU]
f: \genT \fun \genU \\
A: \binop \genT \\
B: \binop \genU
\where
\LET (\_ \mulG \_) == A; (\_ \timesG \_) == B @ \\
\t1	\forall x, y: \genT @ \\
\t2		f(x \mulG y) = (f~x) \timesG (f~y)
\end{schema}

\subsection{\zcmd{homBinOp}}

A map that preserves operations is said to be an {\em operation homomorphism}.

Let $A$ and $B$ be binary operations. 
Let $\homBinOp(A,B)$ denote the set of operation homomorphisms from $A$ to $B$.

\begin{gendef}[\genT, \genU]
\homBinOp: \binop \genT \cross \binop \genU  \fun \power (\genT \fun \genU)
\where
\homBinOp = (\lambda A: \binop \genT; B: \binop \genU @ \\
\t1	\{~ f: \genT \fun \genU | MapPreservesOperation[\genT, \genU] ~\})
\end{gendef}

\begin{remark}
The identity map is an operation homomorphism.
\end{remark}

\begin{remark}
The composition of two operation homomorphisms is an operation homomorphism.
\end{remark}

\section{Semigroups}

\subsection{$OperationIsAssociative$}

A binary operation is said to be {\em associative} if the result of applying it to three elements
is independent of the order in which it is applied pairwise.

Let $OperationIsAssociative$ denote this situation.

\begin{schema}{OperationIsAssociative}[\genT]
A: \binop \genT
\where
\LET (\_ \mulG \_) == A @ \\
\t1	\forall x, y, z: \genT @ \\
\t2		(x \mulG y) \mulG z = x \mulG (y \mulG z)
\end{schema}

\subsection{\zcmd{semigroup}}

Let $\semigroup \genT$ denote the set of all semigroups on the set of elements $\genT$.

\begin{zed}
\semigroup \genT == \{~ A: \binop \genT | OperationIsAssociative[\genT] ~\}
\end{zed}

\subsection{\zcmd{homSemigroup}}

A {\em semigroup homomorphism} from $A$ to $B$ is a homomorphism of the underlying binary operation.

Let $\homSemigroup(A, B)$ denote the set of all semigroup homomorphisms from $A$ to $B$.

\begin{gendef}[\genT, \genU]
\homSemigroup: \semigroup \genT \cross \semigroup \genU \fun \power (\genT \pfun \genU)
\where
\homSemigroup = \\
\t1	(\lambda A: \semigroup \genT; B: \semigroup \genU @ \homBinOp(A, B))
\end{gendef}

\begin{remark}
The identity mapping is a semigroup homomorphism.
\end{remark}

\begin{remark}
The composition of two semigroup homomorphisms is another semigroup homomorphism.
\end{remark}

\section{Monoids}

\subsection{$IdentityElement$}

Let $\genT$ be a set, let $A$ be a binary operation over $\genT$, and let $e$ be an element of $\genT$.
The element $e$ is said to be an {\em identity element} of $A$ if left and right 
products with it leave all elements unchanged.

Let $IdentityElement$ denote this situation.

\begin{schema}{IdentityElement}[\genT]
A: \binop \genT \\
e: \genT
\where
\LET (\_ \mulG \_) == A @ \\
\t1	\forall x: \genT @ \\
\t2		e \mulG x = x = x \mulG e
\end{schema}

\subsection{$identity\_element$}

Let $identity\_element$ denote the relation that associates a binary operation one of its identity elements.

\begin{gendef}[\genT]
identity\_element: \binop \genT \rel \genT
\where
identity\_element = \\
\t1	\{~ IdentityElement[\genT] @ A \mapsto e ~\}
\end{gendef}

\begin{remark}
If a binary operation has an identity element then it is unique.
\end{remark}

\begin{proof}
Let $\mulG$ be a binary operation. Suppose $e$ and $e'$ are identity elements.
\begin{argue}
e \\
\t1	= e \mulG e'	& $e'$ is an identity element \\
\t1	= e'			& $e$ is an identity element
\end{argue}
\end{proof}

\begin{remark}
Since identity elements are unique if they exist, the relation from binary operations to identity elements is a partial function.

\begin{zed}
identity\_element \in \binop \setT \pfun \setT
\end{zed}

\end{remark}


\subsection{Identity Element Symbols \zcmd{zeroG}, and \zcmd{oneG}}

Identity elements are typically denoted by the symbols  $\zeroG$ or $\oneG$.

\subsection{\zcmd{monoid}}

Let $\genT$ be a set of elements.
A {\em monoid} over $\genT$ is a semigroup over $\genT$ that has an identity element.

Let $\monoid \genT$ denote the set of all monoids over $\genT$.

\begin{zed}
\monoid \genT == \{~ A: \semigroup \genT | \exists e: \genT @ IdentityElement[\genT] ~\}
\end{zed}


\subsection{$MapPreservesIdentity$}

Let $A$ and $B$ be monoids and let $f$ map the elements of $A$ to the elements of $B$.
The map $f$ is said to {\em preserve the identity element} if it maps the identity element of $A$
to the identity element of $B$.

Let $MapPreservesIdentity$ denote this situation.

\begin{schema}{MapPreservesIdentity}[\genT, \genU]
f: \genT \fun \genU \\
A: \monoid \genT \\
B: \monoid \genU
\where
\LET e == identity\_element~A; \\
\t1	e' == identity\_element~B @ \\
\t2		f~e = e'
\end{schema}

\subsection{\zcmd{homMonoid}}

A {\em monoid homomorphism} from $A$ to $B$ is a homomorphism $f$ of the underlying semigroups
that preserves identity.

Let $\homMonoid(A, B)$ denote the set of all monoid homomorphisms from $A$ to $B$.

\begin{gendef}[\genT, \genU]
\homMonoid: \monoid \genT \cross \monoid \genU \fun \power (\genT \fun \genU)
\where
\homMonoid = \\
\t1	(\lambda A: \monoid \genT; B: \monoid \genU @ \\
\t2		\{~ f: \homSemigroup(A, B) | \\
\t3			MapPreservesIdentity[\genT, \genU] ~\})
\end{gendef}

\begin{remark}
The identity mapping is a monoid homomorphism.
\end{remark}

\begin{remark}
The composition of two monoid homomorphisms is another monoid homomorphism.
\end{remark}

\section{Groups}

\subsection{$InverseOperation$ and Postfix Operator symbol \zcmd{invG}}

Let $\genT$ be a set of elements and let $A$ be a monoid on $\genT$.
A function $inv \in \genT \fun \genT$ is said to be an {\em inverse operation} if it maps each element
to an element whose product with it is the identity element.
Typically, the expression $x \invG$ is used to denote the inverse of $x$.

Let $InverseOperation$ denote this situation.

\begin{schema}{InverseOperation}[\genT]
A: \monoid \genT \\
inv: \genT \fun \genT
\where
\LET (\_ \mulG \_) == A; \\
\t1	\oneG == identity\_element~A; \\
\t1	(\_ \invG) == inv @ \\
\t2		\forall x: \genT @ \\
\t3			x \mulG x \invG = \oneG = x \invG  \mulG x
\end{schema}

\subsection{$inverse\_operation$}

Let $inverse\_operation$ denote the relation between monoids and their inverse operations.

\begin{gendef}[\genT]
inverse\_operation: \monoid \genT \rel \genT \fun \genT
\where
inverse\_operation = \\
\t1	\{~ InverseOperation[\genT] @ A \mapsto inv ~\}
\end{gendef}

\begin{remark}
If a monoid has an inverse operation then it is unique.
\end{remark}

\begin{proof}
Let $x$ be any element.
Suppose $x \invG$ and $x \daggerG$ are inverses of $x$.
\begin{argue}
x\daggerG \\
\t1	= x\daggerG \mulG \oneG				& $\oneG$ is an identity element \\
\t1	= x\daggerG \mulG (x \mulG x \invG)		& $x \invG$ is an inverse \\
\t1	= (x\daggerG \mulG x) \mulG x \invG		& associativity \\
\t1	= \oneG \mulG x \invG				& $x \daggerG$ is an inverse \\
\t1	= x \invG							& $\oneG$ is an identity element
\end{argue}
\end{proof}

\begin{remark}
Since if inverse operation exist they are unique, the relation between monoids and inverse operations
is a partial function.

\begin{zed}
inverse\_operation \in \monoid \setT \pfun \setT \fun \setT
\end{zed}

\end{remark}

\subsection{$\group$}

A {\em group} is a monoid that has an inverse operation.

Let $\genT$ be a set of elements.
Let $\group \genT$ denote the set of all groups over $\genT$.

\begin{zed}
\group \genT == \{~ A: \monoid \genT | \exists inv: \genT \fun \genT @ InverseOperation[\genT] ~\}
\end{zed}

\subsection{$MapPreservesInverse$}

Let $\genT$ and $\genU$ be sets of elements,
let $A$ and $B$ be groups over $\genT$ and $\genU$, 
and let $f$ map $\genT$ to $\genU$.
The map $f$ is said to {\em preserve the inverses} if it maps the inverses of elements of $A$
to the inverses of the corresponding elements of $B$.

Let $MapPreservesInverse$ denote this situation.

\begin{schema}{MapPreservesInverse}[\genT, \genU]
f: \genT \fun \genU \\
A: \group \genT \\
B: \group \genU
\where
\LET (\_ \invG) == inverse\_operation~A; \\
\t1	(\_ \daggerG) == inverse\_operation~B @ \\
\t2		\forall x: \genT @ \\
\t3			f(x \invG) = (f~x) \daggerG
\end{schema}

\subsection{\zcmd{homGroup}}

Let $A$ and $B$ be groups.
A {\em group homomorphism} from $A$ to $B$ is a monoid homomorphism
from $A$ to $B$ that preserves inverses.

Let $\homGroup(A, B)$ denote the set of all group homomorphisms from $A$ to $B$.

\begin{gendef}[\genT, \genU]
\homGroup: \group \genT \cross \group \genU \fun \power (\genT \fun \genU)
\where
\homGroup = \\
\t1	(\lambda A: \group \genT; B: \group \genU @ \\
\t2		\{~ f: \homMonoid(A, B) | \\
\t3			MapPreservesInverse[\genT, \genU] ~\})
\end{gendef}

\begin{remark}
The identity mapping is a group homomorphism.
\end{remark}

\begin{remark}
The composition of two group homomorphisms is another group homomorphism.
\end{remark}

\subsection{$bij$}

Let $\genT$ be a set and let $bij[\genT]$ denote the set of a bijections $\genT \bij \genT$ from $\genT$ to itself.

\begin{gendef}[\genT]
	bij: \power (\genT \fun \genT)
\where
	bij = \genT \bij \genT
\end{gendef}

\begin{remark}
The composition of bijections is a bijection.

\begin{zed}
	\forall f, g: bij[\setT] @ \\
	\t1	f \circ g \in bij[\setT]
\end{zed}

\end{remark}

\begin{remark}
Composition is associative.

\begin{zed}
	\forall f, g, h: bij[\setT] @ \\
	\t1	f \circ (g \circ h) = (f \circ g) \circ h
\end{zed}

\end{remark}

\begin{remark}
The identity function $\id \setT$ acts as a left and right identity element under composition.

\begin{zed}
	\forall f: bij[\setT] @ \\
	\t1	 \id \setT \circ f = f = f \circ \id \setT
\end{zed}

\end{remark}

\begin{remark}
The inverse $f \inv$ of a bijection $f$ is its left and right inverse under composition.

\begin{zed}
	\forall f: bij[\setT] @ \\
	\t1	f \circ f \inv = \id \setT = f \inv \circ f
\end{zed}

\end{remark}

\subsection{$Bij$}

The preceding remarks show that set $bij[\genT]$ under the operation of composition has the structure of a group.
Let $Bij[\genT]$ denote this group.

\begin{gendef}[\genT]
	Bij: bij[\genT] \cross bij[\genT] \fun bij[\genT]
\where
	Bij = (\lambda f, g: bij[\genT] @ f \circ g)
\end{gendef}

\begin{example}
Let $\setT$ be any non-empty set.
The composition operation $Bij[\setT]$ is a group over the set of bijections $bij[\setT]$ from $\setT$ to $\setT$.

\begin{zed}
\setT \neq \emptyset \implies \\
\t1	Bij[\setT] \in \group bij[\setT]
\end{zed}

\end{example}

\section{Abelian Groups}

\subsection{OperationIsCommutative}

Let $\genT$ be a set of elements.
A binary operation $A$ over $\genT$ is said to be {\em commutative} when the product of two elements doesn't depend on 
their order.

Let $OperationIsCommutative$ denote this situation.

\begin{schema}{OperationIsCommutative}[\genT]
A: \binop \genT
\where
\LET (\_ \mulG \_) == A @ \\
\t1	\forall x, y: \genT @ \\
\t2		x \mulG y = y \mulG x
\end{schema}

\subsection{\zcmd{abgroup}}

An {\em Abelian group} is a group in which the binary operation is commutative.
Let $\genT$ be a set of elements.

Let $\abgroup \genT$ denote the set of all Abelian groups over $\genT$.

\begin{zed}
\abgroup \genT == \{~ A: \group \genT | OperationIsCommutative[\genT] ~\}
\end{zed}

\subsection{\zcmd{addG}, \zcmd{zeroG}, and \zcmd{negG}}

Often in an Abelian group the binary operation is denoted as addition $x \addG y$,
the identity element as a zero $\zeroG$, and the inverse operation as negation $\negG x$.

\begin{example}
Addition over the integers is an Abelian group.

\begin{zed}
	(\_ + \_) \in \abgroup \num
\end{zed}

\end{example}

\printbibliography

\end{document}\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{integers}[2022/02/01 Z Notation for integers package]

% the divisibility infix relation x | y for integers
%%inrel \divides
\newcommand{\divides}{\mathrel{\mid}}

% the addition infix operator x + y for integer sequences
%%inop \addSeqZ 3
\newcommand{\addSeqZ}{\mathbin{+}}
