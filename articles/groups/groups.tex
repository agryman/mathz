\documentclass{amsart}

\usepackage{mathz-sets}
\usepackage{mathz-integers}
\usepackage{mathz-groups}
\usepackage{mathz-preamble}

\addbibresource{../../shared/mathz-references.bib}

\begin{document}

\title{Groups}
\author{Arthur Ryman}
\email[Arthur Ryman]{arthur.ryman@gmail.com}
\date{\today}

\begin{abstract}
This article contains Z Notation definitions for groups and some related objects.
It has been type checked with \fuzz.
\end{abstract}

\maketitle

\tableofcontents

\section{Introduction}

Groups are ubiquitous throughout mathematics and physics.
This article defines groups and their homomorphisms,
building up the definition in terms of some simpler, related algebraic objects,
namely binary operations, semigroups, and monoids.

\section{Structures}

Semigroups, monoids, and groups are defined as sets of elements equipped with a binary operation that has certain properties.
In general, a set equipped with one or more additional features is called a \textit{mathematical structure}.
In particular, semigroups, monoids, and groups are called \textit{algebraic structures}. 
The set of elements in a structure is often referred to as its \textit{carrier}.

In mathematical writing, authors do not normally distinguish between a carrier and its structure
when the structure is clear from context.
For example, one typically see statements such as:  
``Let $G$ be a group and let $g$ be an element of $G$.''
However, a set of elements may have more than one structure is a given context.
For example, addition and multiplication are distinct binary operations on the set of integers.
In this case it is insufficient to specify only the set of elements.
Distinct mathematical objects
must be referred to using distinct names or expressions.

In order to distinguish between sets of elements and structures on them, 
this article adopts the common practice of defining structures as being \textit{tuples}
consisting of the set of elements and one or more additional features.

\section{Binary Operations}

Let $\genT$ be a set from which we draw elements.
Let $elements$ be a set of elements drawn from $\genT$ and
let $op$ be an operation that maps each pair of elements to some other element.
We call the pair $(elements, op)$ a \textit{binary operation on the set} $elements$.
Furthermore, we say that it is a \textit{binary operation in} $\genT$.

\begin{schema}{BinaryOperation}[\genT]
	elements: \power \genT \\
	op: \genT \cross \genT \pfun \genT
\where
	op \in elements \cross elements \fun elements
\end{schema}
\begin{itemize}
	\item The set of elements is closed under the operation.
\end{itemize}

Let $binary\_operation[\genT]$ be the set of all binary operations in $\genT$.
\begin{zed}
	binary\_operation[\genT] == \{~ BinaryOperation[\genT] @ (elements, op) ~\}
\end{zed}

Let the notation $\binop \genT$ denote the set of all binary operations in $\genT$.
\begin{zed}
	\binop \genT == binary\_operation[\genT]
\end{zed}

Let $integer\_addition$ be the binary operation of integer addition.
\begin{zed}
	integer\_addition == (\num, (\_ + \_))
\end{zed}

\begin{example}
Integer addition is a binary operation on $\num$.
\begin{zed}
	integer\_addition \in \binop \num
\end{zed}
\end{example}

Let $integer\_multiplication$ denote the binary operation of integer multiplication.
\begin{zed}
	integer\_multiplication == (\num, (\_ * \_))
\end{zed}

\begin{example}
Integer multiplication is a binary operation on $\num$.
\begin{zed}
	integer\_multiplication \in binary\_operation[\num]
\end{zed}
\end{example}

\subsection{Notational Convention for Structures}

The set of elements in a binary operation is normally denoted by variables such as $A$ or $B$.
As a notational convention, we'll denote the corresponding structures by variables such as $\strucA$ or $\strucB$.

The result of applying a binary operation to a pair of elements $(x, y)$ 
is normally denoted by an expression formed using an infix operator symbol,
e.g. $x + y$ or $x * y$.

Let $\genT$ and $\genU$ be sets, 
let $A \subseteq \genT$ and $B \subseteq \genU$ be subsets of elements,
and let the infix expression $x * y$ denote binary operations on both $A$ and $B$.
Here we follow the traditional practice of using the same symbol to denote different things when no confusion can occur.
Although the symbols look the same, they are encoded distinctly at the source level,
namely using the commands \verb|\mulA| and \verb|\mulB|.
This practice makes the typeset expressions look as natural as possible while at the same time satisfying the type checker.

Let $BinaryOperation\_A$ denote the binary operation $\strucA$ where $A$ is the set of elements and 
$(\_  \mulA \_)$ is the operator using \verb|\mulA|.
\begin{schema}{BinaryOperation\_A}[\genT]
	BinaryOperation[\genT][A / elements, \_ \mulA \_ / op] \\
	\strucA: \binop \genT
\where
	\strucA = (A, (\_ \mulA \_))
\end{schema}

Similarly, let $BinaryOperation\_B$ denote the binary operation $\strucB$ where $B$ is the set of elements and 
$(\_ \mulB \_)$ is the operator using \verb|\mulB|.
\begin{schema}{BinaryOperation\_B}[\genU]
	BinaryOperation[\genU][B / elements, \_ \mulB \_ / op] \\
	\strucB: \binop \genU
\where
	\strucB = (B, (\_ \mulB \_))
\end{schema}

\subsection{Homomorphisms}

Let $\strucA$ and $\strucB$ be binary operations and let $f$ map $A$ to $B$.
\begin{schema}{Map\_AB}[\genT, \genU]
	BinaryOperation\_A[\genT] \\
	BinaryOperation\_B[\genU] \\
	f: \genT \pfun \genU
\where
	f \in A \fun B
\end{schema}

The map $f$ is said to {\em preserve the operations} if it maps the product of elements of $A$ to 
the product of the mapped elements of $B$.
\begin{schema}{MapPreservesOperations}[\genT, \genU]
	Map\_AB[\genT, \genU]
\where
	\forall x, y: A @ \\
	\t1	f(x \mulA y) = (f~x) \mulB (f~y)
\end{schema}

\begin{example}
Multiplication by a fixed integer $c$ maps $\num$ to $\num$ and preserves addition.
\begin{zed}
	\forall c, x, y: \num @ \\
	\t1	c * (x + y) = c * x + c * y
\end{zed}

Therefore
\begin{zed}
	\forall Map\_AB[\num, \num]; c: \num | \\
	\t1	\strucA = \strucB = (\num, (\_ +  \_)) \land \\
	\t1	f = (\lambda x: \num @ c * x) @ \\
	\t2		MapPreservesOperations[\num, \num]
\end{zed}
\end{example}

\begin{example}
Exponentiation by a fixed natural number $n$ maps $\num$ to $\num$ and preserves multiplication.
\begin{zed}
	\forall n: \nat; x, y: \num @ \\
	\t1	(x * y) \expN n = x \expN n * y \expN n
\end{zed}
\end{example}

A map that preserves operations is said to be an \textit{operation homomorphism}.
Let $\strucA, \strucB$ be binary operations in $\genT$ and $\genU$. 
Let $hom\_op[\genT, \genU](\strucA, \strucB)$ denote the set of all operation homomorphisms from $\strucA$ to $\strucB$.

\begin{zed}
	hom\_op[\genT, \genU] == \\
	\t1	(\lambda \alpha: \binop \genT; \beta: \binop \genU @ \\
	\t2		\{~ MapPreservesOperations[\genT, \genU] | \alpha = \strucA \land \beta = \strucB @ f ~\})
\end{zed}

TODO: try to simplify the above by using a gendef paragraph.

\begin{remark}
\begin{zed}
	hom\_op[\setT, \setU] \in \binop \setT \cross \binop \setU \fun \power (\setT \pfun \setU)
\end{zed}
\end{remark}

Let the notation $\homBinOp(\alpha, \beta)$,  typeset using the command \verb|\homBinOp|, 
denote the set of operation homomorphisms from $\alpha$ to $\beta$.

\begin{zed}
	\homBinOp[\genT, \genU] == hom\_op[\genT, \genU]
\end{zed}

\begin{remark}
The identity map preserves all operations.
\begin{zed}
	\forall \strucA: \binop \setX @ \\
	\t1	\id \setX \in \homBinOp(\strucA, \strucA)
\end{zed}
\end{remark}

\begin{remark}
The composition of two operation homomorphisms is an operation homomorphism.
\begin{zed}
	\forall \strucA: \binop \setX; \strucB: \binop \setY; \strucC: \binop \setZ @ \\
	\t1	\forall f: \homBinOp(\strucA, \strucB); g: \homBinOp(\strucB, \strucC) @ \\
	\t2		g \circ f \in \homBinOp(\strucA, \strucC)
\end{zed}
\end{remark}

\section{Semigroups}

\subsection{$OperationIsAssociative$}

A binary operation is said to be \textit{associative} if the result of applying it to any three elements
is independent of the order in which it is applied pairwise.

\begin{schema}{OperationIsAssociative}[\genT]
	BinaryOperation\_A[\genT]
\where
	\forall x, y, z: A @ \\
	\t1	x \mulA y \mulA z = x \mulA (y \mulA z)
\end{schema}

A set of elements with an associative binary operation is called a \textit{semigroup}.
\begin{schema}{Semigroup\_A}[\genT]
	OperationIsAssociative[\genT]
\end{schema}

Let $semigroup[\genT]$ denote the set of all semigroups in $\genT$.

\begin{zed}
	semigroup[\genT] == \{~ Semigroup\_A[\genT] @ \strucA  ~\}
\end{zed}

Let the notation $\semigroup \genT$, typeset using the prefix generic command \verb|\semigroup|,
denote the set of all semigroups in $\genT$.

\begin{zed}
	\semigroup \genT == semigroup[\genT]
\end{zed}

\begin{remark}
\begin{zed}
	\semigroup \setT \subseteq \binop \setT
\end{zed}
\end{remark}

A \textit{semigroup homomorphism} is a homomorphism of the underlying binary operation.

Let $\strucA, \strucB$ be semigroups in $\genT, \genU$.
Let $hom\_semigroup(\strucA, \strucB)$ denote the set of semigroup homomorphisms from $\strucA$ to $\strucB$.

\begin{zed}
	hom\_semigroup[\genT, \genU] == \\
	\t1	(\lambda \strucA: \semigroup \genT; \strucB: \semigroup \genU @ \homBinOp(\strucA, \strucB))
\end{zed}

Note that as a type, semigroups are a subset of binary operations.
The operation homomorphisms of a semigroup are the same as the semigroup homomorphisms.

If A is a semigroup and B is a binary operation and f is an operation homomorphism then the image of f is a semigroup.

Let $\homSemigroup(A, B)$ denote the set of all semigroup homomorphisms from $A$ to $B$.

\begin{gendef}[\genT, \genU]
	\homSemigroup: \semigroup \genT \cross \semigroup \genU \fun \power (\genT \pfun \genU)
\where
	\homSemigroup = \\
	\t1	(\lambda A: \semigroup \genT; B: \semigroup \genU @ \homBinOp(A, B))
\end{gendef}

\begin{remark}
The identity mapping is a semigroup homomorphism.
\end{remark}

\begin{remark}
The composition of two semigroup homomorphisms is another semigroup homomorphism.
\end{remark}

\section{Monoids}

Let $\genT$ be a set, let $\strucA = (A, (\_ \mulA \_))$ be a binary operation in $\genT$, and let $e$ be an element of $A$.
The element $e$ is said to be an \textit{identity element} of $A$ if left and right 
products with it leave all elements unchanged.
\begin{schema}{IdentityElement\_A}[\genT]
	BinaryOperation\_A[\genT] \\
	e: \genT
\where
	e \in A
\also
	\forall x: A @ e \mulA x = x = x \mulA e
\end{schema}

Let $identity\_element$ denote the relation between binary operations and identity elements.
\begin{zed}
	identity\_element[\genT] == \\
	\t1	\{~ IdentityElement\_A[\genT] @ \strucA \mapsto e ~\}
\end{zed}

\begin{remark}
\begin{zed}
	identity\_element[\setT] \in \binop \setT \rel \setT
\end{zed}
\end{remark}

Consider the case of a binary operation $\strucA$ that has, possibly distinct, identity elements $e, e'$.
\begin{schema}{IdentityElements\_A}[\genT]
	BinaryOperation\_A[\genT] \\
	e, e': \genT
\where
	\{ \strucA \} \cross \{ e, e' \} \subseteq identity\_element[\genT]
\end{schema}

\begin{remark}
If a binary operation has an identity element then it is unique.

\begin{zed}
	\forall IdentityElements\_A[\setT] @ e = e'
\end{zed}

\begin{proof}
\begin{argue}
e \\
\t1	= e \mulA e'	& $e'$ is an identity element \\
\t1	= e'			& $e$ is an identity element
\end{argue}
\end{proof}

\end{remark}

\begin{remark}
If an identity element exists then it is unique.
Therefore the relation from binary operations to identity elements is a partial function.

\begin{zed}
identity\_element[\setT] \in \binop \setT \pfun \setT
\end{zed}

\end{remark}

Identity elements are typically denoted by the symbols  $\zeroG$ or $\oneG$.

A {\em monoid} in $\genT$ is a semigroup in $\genT$ that has an identity element.
\begin{schema}{Monoid\_A}[\genT]
	Semigroup\_A[\genT] \\
	IdentityElement\_A[\genT]
\end{schema}

Let $\monoid \genT$ denote the set of all monoids in $\genT$.
\begin{zed}
	\monoid \genT == \{~ Monoid\_A[\genT] @ \strucA ~\}
\end{zed}


\subsection{$MapPreservesIdentity$}

Let $A$ and $B$ be monoids and let $f$ map the elements of $A$ to the elements of $B$.
The map $f$ is said to {\em preserve the identity element} if it maps the identity element of $A$
to the identity element of $B$.

Let $MapPreservesIdentity$ denote this situation.

\begin{schema}{MapPreservesIdentity}[\genT, \genU]
f: \genT \pfun \genU \\
A: \monoid \genT \\
B: \monoid \genU
\where
\LET e == identity\_element~A; \\
\t1	e' == identity\_element~B @ \\
\t2		f~e = e'
\end{schema}

\subsection{\zcmd{homMonoid}}

A {\em monoid homomorphism} from $A$ to $B$ is a homomorphism $f$ of the underlying semigroups
that preserves identity.

Let $\homMonoid(A, B)$ denote the set of all monoid homomorphisms from $A$ to $B$.

\begin{gendef}[\genT, \genU]
\homMonoid: \monoid \genT \cross \monoid \genU \fun \power (\genT \fun \genU)
\where
\homMonoid = \\
\t1	(\lambda A: \monoid \genT; B: \monoid \genU @ \\
\t2		\{~ f: \homSemigroup(A, B) | \\
\t3			MapPreservesIdentity[\genT, \genU] ~\})
\end{gendef}

\begin{remark}
The identity mapping is a monoid homomorphism.
\end{remark}

\begin{remark}
The composition of two monoid homomorphisms is another monoid homomorphism.
\end{remark}

\section{Groups}

Let $\strucA$ be a monoid in $\genT$.
A function $inv \in A \fun A$ is said to be an \textit{inverse operation} if it maps each element
to an element whose product with it is the identity element.
Typically, the postfix expression $x \invG$ is used to denote the inverse of $x$.

\begin{schema}{InverseOperation\_A}[\genT]
	Monoid\_A[\genT] \\
	inv: \genT \pfun \genT
\where
	inv \in A \fun A
\also
	\LET (\_ \invG) == inv @ \\
	\t1	\forall x: A @ \\
	\t2		x \mulA x \invG = e = x \invG  \mulA x
\end{schema}

\subsection{$inverse\_operation$}

Let $inverse\_operation$ denote the relation between monoids and their inverse operations.
\begin{zed}
inverse\_operation[\genT] == \\
\t1	\{~ InverseOperation\_A[\genT] @ \strucA \mapsto inv ~\}
\end{zed}

\begin{remark}
If a monoid has an inverse operation then it is unique.
\end{remark}

\begin{proof}
Let $x$ be any element.
Suppose $x \invG$ and $x \daggerG$ are inverses of $x$.
\begin{argue}
x\daggerG \\
\t1	= x\daggerG \mulG \oneG				& $\oneG$ is an identity element \\
\t1	= x\daggerG \mulG (x \mulG x \invG)		& $x \invG$ is an inverse \\
\t1	= (x\daggerG \mulG x) \mulG x \invG		& associativity \\
\t1	= \oneG \mulG x \invG				& $x \daggerG$ is an inverse \\
\t1	= x \invG							& $\oneG$ is an identity element
\end{argue}
\end{proof}

\begin{remark}
Since inverse operations are unique if exist they, the relation between monoids and inverse operations
is a partial function.

\begin{zed}
inverse\_operation \in \monoid \setT \pfun \setT \pfun \setT
\end{zed}

\end{remark}

\subsection{$\group$}

A {\em group} is a monoid that has an inverse operation.
\begin{schema}{Group\_A}[\genT]
	InverseOperation\_A[\genT]
\end{schema}

Let $\genT$ be a set of elements.
Let $\group \genT$ denote the set of all groups over $\genT$.
\begin{zed}
	\group \genT == \{~ Group\_A[\genT] @ \strucA ~\}
\end{zed}

\subsection{$MapPreservesInverse$}

Let $\genT$ and $\genU$ be sets of elements,
let $A$ and $B$ be groups over $\genT$ and $\genU$, 
and let $f$ map $\genT$ to $\genU$.
The map $f$ is said to {\em preserve the inverses} if it maps the inverses of elements of $A$
to the inverses of the corresponding elements of $B$.

Let $MapPreservesInverse$ denote this situation.

\begin{schema}{MapPreservesInverse}[\genT, \genU]
f: \genT \pfun \genU \\
A: \group \genT \\
B: \group \genU
\where
\LET (\_ \invG) == inverse\_operation~A; \\
\t1	(\_ \daggerG) == inverse\_operation~B @ \\
\t2		\forall x: \genT @ \\
\t3			f(x \invG) = (f~x) \daggerG
\end{schema}

\subsection{\zcmd{homGroup}}

Let $A$ and $B$ be groups.
A {\em group homomorphism} from $A$ to $B$ is a monoid homomorphism
from $A$ to $B$ that preserves inverses.

Let $\homGroup(A, B)$ denote the set of all group homomorphisms from $A$ to $B$.

\begin{gendef}[\genT, \genU]
\homGroup: \group \genT \cross \group \genU \fun \power (\genT \fun \genU)
\where
\homGroup = \\
\t1	(\lambda A: \group \genT; B: \group \genU @ \\
\t2		\{~ f: \homMonoid(A, B) | \\
\t3			MapPreservesInverse[\genT, \genU] ~\})
\end{gendef}

\begin{remark}
The identity mapping is a group homomorphism.
\end{remark}

\begin{remark}
The composition of two group homomorphisms is another group homomorphism.
\end{remark}

\subsection{$bij$}

Let $\genT$ be a set and let $bij[\genT]$ denote the set of a bijections $\genT \bij \genT$ from $\genT$ to itself.

\begin{zed}
	bij[\genT] == \genT \bij \genT
\end{zed}

\begin{remark}
The composition of bijections is a bijection.

\begin{zed}
	\forall f, g: bij[\setT] @ \\
	\t1	f \circ g \in bij[\setT]
\end{zed}

\end{remark}

\begin{remark}
Composition is associative.

\begin{zed}
	\forall f, g, h: bij[\setT] @ \\
	\t1	f \circ (g \circ h) = (f \circ g) \circ h
\end{zed}

\end{remark}

\begin{remark}
The identity function $\id \setT$ acts as a left and right identity element under composition.

\begin{zed}
	\forall f: bij[\setT] @ \\
	\t1	 \id \setT \circ f = f = f \circ \id \setT
\end{zed}

\end{remark}

\begin{remark}
The inverse $f \inv$ of a bijection $f$ is its left and right inverse under composition.

\begin{zed}
	\forall f: bij[\setT] @ \\
	\t1	f \circ f \inv = \id \setT = f \inv \circ f
\end{zed}

\end{remark}

\subsection{$Bij$}

The preceding remarks show that set $bij[\genT]$ under the operation of composition has the structure of a group.
Let $Bij[\genT]$ denote the composition of bijections.

\begin{zed}
	Bij[\genT] == (\lambda f, g: bij[\genT] @ f \circ g)
\end{zed}

\begin{example}
Let $\setT$ be any set.
The composition of bijections of $\setT$ is a group.

\begin{zed}
(bij[\setT], Bij[\setT]) \in \group bij[\setT]
\end{zed}

\end{example}

\section{Abelian Groups}

\subsection{OperationIsCommutative}

A binary operation $\strucA$ in $\genT$ is said to be {\em commutative} when the product of two elements doesn't depend on 
their order.

\begin{schema}{OperationIsCommutative\_A}[\genT]
	BinaryOperation\_A[\genT]
\where
	\forall x, y: A @ x \mulA y = y \mulA x
\end{schema}

\subsection{\zcmd{abgroup}}

An {\em abelian group} is a group in which the binary operation is commutative.
\begin{schema}{AbelianGroup\_A}[\genT]
	Group\_A[\genT] \\
	OperationIsCommutative\_A[\genT]
\end{schema}

Let $\abgroup \genT$ denote the set of all abelian groups in $\genT$.
\begin{zed}
\abgroup \genT == \{~ AbelianGroup\_A[\genT] @ \strucA ~\}
\end{zed}

\subsection{\zcmd{addG}, \zcmd{zeroG}, and \zcmd{negG}}

Often in an abelian group the binary operation is denoted as addition $x \addG y$,
the identity element as a zero $\zeroG$, and the inverse operation as negation $\negG x$.

\begin{example}
Addition over the integers is an abelian group.

\begin{zed}
	(\num, (\_ + \_)) \in \abgroup \num
\end{zed}

\end{example}

\printbibliography

\end{document}