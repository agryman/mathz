\documentclass{amsart}

\usepackage{mathz-sets}
\usepackage{mathz-integers}
\usepackage{mathz-groups}
\usepackage{mathz-preamble}

\addbibresource{../../shared/references.bib}

\begin{document}

\title{Groups}
\author{Arthur Ryman}
\email[Arthur Ryman]{arthur.ryman@gmail.com}
\date{\today}

\begin{abstract}
This article contains Z Notation definitions for groups and some related objects.
It has been type checked with \fuzz.
\end{abstract}

\maketitle

\tableofcontents

\section{Introduction}

Groups are ubiquitous throughout mathematics and physics.
This article defines groups and their homomorphisms.

We build up the definition of a group in terms of some simpler, related algebraic objects,
namely semigroups and monoids.

\subsection{Structures}

Semigroups, monoids, and groups are defined as sets of elements with an additional feature,
namely a binary operation that has certain properties.
In general, a set with some additional features is called a \textit{mathematical structure}.
In particular, semigroups, monoids, and groups are called \textit{algebraic structures}. 

In mathematical writing, authors do not normally distinguish between a set of elements and its associated mathematical structure
since this rarely causes confusion.
For example, one typically see statements such as:  ``Let $G$ be a group and let $g \in G$ be an element.''
However, a set of elements may be given many inequivalent structures.
For example, addition and multiplication are distinct binary operations on the set of integers.
In this case it is insufficient to specify only the set of elements.

In natural language, the practice of \textit{metonymy}, which consists of referring to a thing, e.g. an algebraic structure, 
by naming a part of it, e.g. its set of elements, normally causes no confusion.
However, an algebraic structure and its set of elements are distinct mathematical objects
and so, in formal language, must be referred to using distinct names or expressions.

In order to distinguish between sets of elements and structures on them, 
we will adopt the practice of defining structures as being tuples consisting of the set of elements and one of more additional features.

\section{Binary Operations}

Let $\genT$ be a set which we regard as a universe from which we draw elements.
Let $elements \subseteq \genT$ be a set of elements drawn from $\genT$
let $op \in elements \cross element \fun elements$ be an operation that combines pairs of elements to give another element.
We call the pair $(elements, op)$ a \textit{binary operation} on $elements$.
Furthermore, say that it is a binary relation \textit{in} the universe $\genT$.

\begin{schema}{BinaryOperation}[\genT]
	elements: \power \genT \\
	op: \genT \cross \genT \pfun \genT
\where
	op \in elements \cross elements \fun elements
\end{schema}
\begin{itemize}
	\item The set of elements is closed under the operation.
\end{itemize}

Let $binary\_operation[\genT]$ denote the set of all binary operations in $\genT$.

\begin{zed}
	binary\_operation[\genT] == \{~ BinaryOperation[\genT] @ (elements, op) ~\}
\end{zed}

\begin{example}
Integer addition is a binary operation on $\num$.
\begin{zed}
	(\num, (\_ + \_)) \in binary\_operation[\num]
\end{zed}
\end{example}

\begin{example}
Integer multiplication is a binary operation on $\num$.
\begin{zed}
	(\num, (\_ * \_)) \in binary\_operation[\num]
\end{zed}
\end{example}

Let the prefix generic notation $\binop \genT$ denote the set of all binary operations in $\genT$.

\begin{zed}
	\binop \genT == binary\_operation[\genT]
\end{zed}

\subsection{Notation}

The set of elements in a binary operation is normally denoted by variables such as $A$ or $B$.
As a notational convention, we'll denote the corresponding structures by variables such as $\strucA$ or $\strucB$.

The result of applying a binary operation to a pair of elements $(x, y)$ 
is normally denoted by an expression formed using an infix operator symbol,
e.g. $x + y$ or $x * y$.

Let $\genT$ and $\genU$ be sets, 
let $A \subseteq \genT$ and $B \subseteq \genU$ be subsets of elements,
and let the infix expression $x * y$ denote binary operations on both $A$ and $B$.
Here we follow the traditional practice of using the same symbol to denote different things when no confusion can occur.
Although the symbols look the same, they are encoded distinctly at the source level,
namely using the commands \verb|\mulA| and \verb|\mulB|.
This practice makes the typeset expressions look as natural as possible while at the same time satisfying the type checker.

Let $BinaryOperation\_A$ denote the binary operation $\strucA$ where $A$ is the set of elements and $*$ (encoded as \verb|\mulA|) is the operator.
\begin{schema}{BinaryOperation\_A}[\genT]
	BinaryOperation[\genT][A / elements, \_ \mulA \_ / op] \\
	\strucA: \binop \genT
\where
	\strucA = (A, (\_ \mulA \_))
\end{schema}

Let $BinaryOperation\_B$ denote the binary operation $\strucB$ where $B$ is the set of elements and $*$ (encoded as \verb|\mulB|) is the operator.
\begin{schema}{BinaryOperation\_B}[\genU]
	BinaryOperation[\genU][B / elements, \_ \mulB \_ / op] \\
	\strucB: \binop \genU
\where
	\strucB = (B, (\_ \mulB \_))
\end{schema}

\subsection{Homomorphisms}

Let $\strucA$ and $\strucB$ be binary operations and let $f \in A \fun B$ be a function.
Then $f$ is said to {\em preserve the operations} if it maps the product of elements of $A$ to 
the product of the mapped elements of $B$.

Let $MapPreservesOperation$ denote this situation.
\begin{schema}{MapPreservesOperation}[\genT, \genU]
	BinaryOperation\_A[\genT] \\
	BinaryOperation\_B[\genU] \\
	f: \genT \pfun \genU
\where
	f \in A \fun B
\also
	\forall x, y: A @ \\
	\t1	f(x \mulA y) = (f~x) \mulB (f~y)
\end{schema}
\begin{itemize}
	\item $f$ is a total function from $A$ to $B$
	\item $f$ preserves the binary operations
\end{itemize}

TODO: express this examples in terms of the schema $MapPreservesOperation$.

\begin{example}
Multiplication by a fixed integer $c$ maps $\num$ to $\num$ and preserves addition.
\begin{zed}
	\forall c, x, y: \num @ \\
	\t1	c * (x + y) = c * x + c * y
\end{zed}
\end{example}

\begin{example}
Exponentiation by a fixed natural number $n$ maps $\num$ to $\num$ and preserves multiplication.
\begin{zed}
	\forall n: \nat; x, y: \num @ \\
	\t1	(x * y) \expN n = x \expN n * y \expN n
\end{zed}
\end{example}

A map that preserves operations is said to be an \textit{operation homomorphism}.
Let $\alpha = (A, *)$ and $\beta = (B, *)$ be binary operations in $\genT$ and $\genU$. 
Let $hom\_op[\genT, \genU](\alpha,\beta)$ denote the set of all operation homomorphisms from $\alpha$ to $\beta$.

\begin{zed}
	hom\_op[\genT, \genU] == \\
	\t1	(\lambda \alpha: \binop \genT; \beta: \binop \genU @ \\
	\t2		\{~ MapPreservesOperation[\genT, \genU] | \\
	\t3			\alpha = (A, (\_ \mulA \_)) \land \\
	\t3			\beta = (B, (\_ \mulB \_)) @ \\
	\t4				f ~\})
\end{zed}

TODO: try to simplify the above by using a gendef paragraph.

\begin{remark}
\begin{zed}
	hom\_op[\setT, \setU] \in \binop \setT \cross \binop \setU \fun \power (\setT \pfun \setU)
\end{zed}
\end{remark}

Let the notation $\homBinOp(\alpha, \beta)$,  typeset using the command \verb|\homBinOp|, 
denote the set of operation homomorphisms from $\alpha$ to $\beta$.

\begin{zed}
	\homBinOp[\genT, \genU] == hom\_op[\genT, \genU]
\end{zed}

\begin{remark}
The identity map preserves all operations.
\begin{zed}
	\forall A: \binop \setX @ \\
	\t1	\id \setX \in \homBinOp(A, A)
\end{zed}
\end{remark}

\begin{remark}
The composition of two operation homomorphisms is an operation homomorphism.
\begin{zed}
	\forall A: \binop \setX; B: \binop \setY; C: \binop \setZ @ \\
	\t1	\forall f: \homBinOp(A, B); g: \homBinOp(B, C) @ \\
	\t2		g \circ f \in \homBinOp(A, C)
\end{zed}
\end{remark}

\section{Semigroups}

\subsection{$OperationIsAssociative$}

A binary operation is said to be \textit{associative} if the result of applying it to three elements
is independent of the order in which it is applied pairwise.

Let $OperationIsAssociative$ denote this situation.

\begin{schema}{OperationIsAssociative}[\genT]
A: \binop \genT
\where
	\forall x, y, z: \genT @ \\
	\t1		A(A(x, y), z) = A(x, A(y, z))
\end{schema}

A set of elements $\genT$ with an associative binary operation is called a \textit{semigroup}.
Let $semigroup[\genT]$ denote the set of all semigroups with elements $\genT$.

\begin{zed}
	semigroup[\genT] == \{~ OperationIsAssociative[\genT] @ A  ~\}
\end{zed}

Let the notation $\semigroup \genT$, typeset using the prefix generic command \verb|\semigroup|,
denote the set of all semigroups on the set of elements $\genT$.

\begin{zed}
	\semigroup \genT == semigroup[\genT]
\end{zed}

\begin{remark}
\begin{zed}
	\semigroup \setT \subseteq \binop \setT
\end{zed}
\end{remark}

A \textit{semigroup homomorphism} from $A$ to $B$ is a homomorphism of the underlying binary operation.

Let $hom\_semigroup(A,B)$ denote the set of semigroup homomorphism from $A$ to $B$.

\begin{zed}
	hom\_semigroup[\setT, \setU] == \\
	\t1	(\lambda A: \semigroup \setT; B: \semigroup \setU @ \homBinOp(A, B))
\end{zed}

STOPPED HERE.

Note that as a type, semigroups are a subset of binary operations.
The operation homomorphisms of a semigroup are the same as the semigroup homomorphisms.

Is it clearer to introduce explicit additional structure?
e.g. a semigroup is a pair (X, op) where X is a set of elements and op is a binary operation on X.

A monoid is a triple (X, op, e) where (X, op) is a semigroup and e is an identity element.

Try to define the category of semigroups. Do I need to duplicate the definitions to allow elements being subsets of the formal generic parameters?

If A is a semigroup and B is a binary operation and f is an operation homomorphism then the image of f is a semigroup.

Let $\homSemigroup(A, B)$ denote the set of all semigroup homomorphisms from $A$ to $B$.

\begin{gendef}[\genT, \genU]
	\homSemigroup: \semigroup \genT \cross \semigroup \genU \fun \power (\genT \pfun \genU)
\where
	\homSemigroup = \\
	\t1	(\lambda A: \semigroup \genT; B: \semigroup \genU @ \homBinOp(A, B))
\end{gendef}

\begin{remark}
The identity mapping is a semigroup homomorphism.
\end{remark}

\begin{remark}
The composition of two semigroup homomorphisms is another semigroup homomorphism.
\end{remark}

\section{Monoids}

\subsection{$IdentityElement$}

Let $\genT$ be a set, let $A$ be a binary operation over $\genT$, and let $e$ be an element of $\genT$.
The element $e$ is said to be an {\em identity element} of $A$ if left and right 
products with it leave all elements unchanged.

Let $IdentityElement$ denote this situation.

\begin{schema}{IdentityElement}[\genT]
A: \binop \genT \\
e: \genT
\where
\LET (\_ \mulG \_) == A @ \\
\t1	\forall x: \genT @ \\
\t2		e \mulG x = x = x \mulG e
\end{schema}

\subsection{$identity\_element$}

Let $identity\_element$ denote the relation that associates a binary operation one of its identity elements.

\begin{gendef}[\genT]
identity\_element: \binop \genT \rel \genT
\where
identity\_element = \\
\t1	\{~ IdentityElement[\genT] @ A \mapsto e ~\}
\end{gendef}

\begin{remark}
If a binary operation has an identity element then it is unique.
\end{remark}

\begin{proof}
Let $\mulG$ be a binary operation. Suppose $e$ and $e'$ are identity elements.
\begin{argue}
e \\
\t1	= e \mulG e'	& $e'$ is an identity element \\
\t1	= e'			& $e$ is an identity element
\end{argue}
\end{proof}

\begin{remark}
Since identity elements are unique if they exist, the relation from binary operations to identity elements is a partial function.

\begin{zed}
identity\_element \in \binop \setT \pfun \setT
\end{zed}

\end{remark}


\subsection{Identity Element Symbols \zcmd{zeroG}, and \zcmd{oneG}}

Identity elements are typically denoted by the symbols  $\zeroG$ or $\oneG$.

\subsection{\zcmd{monoid}}

Let $\genT$ be a set of elements.
A {\em monoid} over $\genT$ is a semigroup over $\genT$ that has an identity element.

Let $\monoid \genT$ denote the set of all monoids over $\genT$.

\begin{zed}
\monoid \genT == \{~ A: \semigroup \genT | \exists e: \genT @ IdentityElement[\genT] ~\}
\end{zed}


\subsection{$MapPreservesIdentity$}

Let $A$ and $B$ be monoids and let $f$ map the elements of $A$ to the elements of $B$.
The map $f$ is said to {\em preserve the identity element} if it maps the identity element of $A$
to the identity element of $B$.

Let $MapPreservesIdentity$ denote this situation.

\begin{schema}{MapPreservesIdentity}[\genT, \genU]
f: \genT \fun \genU \\
A: \monoid \genT \\
B: \monoid \genU
\where
\LET e == identity\_element~A; \\
\t1	e' == identity\_element~B @ \\
\t2		f~e = e'
\end{schema}

\subsection{\zcmd{homMonoid}}

A {\em monoid homomorphism} from $A$ to $B$ is a homomorphism $f$ of the underlying semigroups
that preserves identity.

Let $\homMonoid(A, B)$ denote the set of all monoid homomorphisms from $A$ to $B$.

\begin{gendef}[\genT, \genU]
\homMonoid: \monoid \genT \cross \monoid \genU \fun \power (\genT \fun \genU)
\where
\homMonoid = \\
\t1	(\lambda A: \monoid \genT; B: \monoid \genU @ \\
\t2		\{~ f: \homSemigroup(A, B) | \\
\t3			MapPreservesIdentity[\genT, \genU] ~\})
\end{gendef}

\begin{remark}
The identity mapping is a monoid homomorphism.
\end{remark}

\begin{remark}
The composition of two monoid homomorphisms is another monoid homomorphism.
\end{remark}

\section{Groups}

\subsection{$InverseOperation$ and Postfix Operator symbol \zcmd{invG}}

Let $\genT$ be a set of elements and let $A$ be a monoid on $\genT$.
A function $inv \in \genT \fun \genT$ is said to be an {\em inverse operation} if it maps each element
to an element whose product with it is the identity element.
Typically, the expression $x \invG$ is used to denote the inverse of $x$.

Let $InverseOperation$ denote this situation.

\begin{schema}{InverseOperation}[\genT]
A: \monoid \genT \\
inv: \genT \fun \genT
\where
\LET (\_ \mulG \_) == A; \\
\t1	\oneG == identity\_element~A; \\
\t1	(\_ \invG) == inv @ \\
\t2		\forall x: \genT @ \\
\t3			x \mulG x \invG = \oneG = x \invG  \mulG x
\end{schema}

\subsection{$inverse\_operation$}

Let $inverse\_operation$ denote the relation between monoids and their inverse operations.

\begin{gendef}[\genT]
inverse\_operation: \monoid \genT \rel \genT \fun \genT
\where
inverse\_operation = \\
\t1	\{~ InverseOperation[\genT] @ A \mapsto inv ~\}
\end{gendef}

\begin{remark}
If a monoid has an inverse operation then it is unique.
\end{remark}

\begin{proof}
Let $x$ be any element.
Suppose $x \invG$ and $x \daggerG$ are inverses of $x$.
\begin{argue}
x\daggerG \\
\t1	= x\daggerG \mulG \oneG				& $\oneG$ is an identity element \\
\t1	= x\daggerG \mulG (x \mulG x \invG)		& $x \invG$ is an inverse \\
\t1	= (x\daggerG \mulG x) \mulG x \invG		& associativity \\
\t1	= \oneG \mulG x \invG				& $x \daggerG$ is an inverse \\
\t1	= x \invG							& $\oneG$ is an identity element
\end{argue}
\end{proof}

\begin{remark}
Since if inverse operation exist they are unique, the relation between monoids and inverse operations
is a partial function.

\begin{zed}
inverse\_operation \in \monoid \setT \pfun \setT \fun \setT
\end{zed}

\end{remark}

\subsection{$\group$}

A {\em group} is a monoid that has an inverse operation.

Let $\genT$ be a set of elements.
Let $\group \genT$ denote the set of all groups over $\genT$.

\begin{zed}
\group \genT == \{~ A: \monoid \genT | \exists inv: \genT \fun \genT @ InverseOperation[\genT] ~\}
\end{zed}

\subsection{$MapPreservesInverse$}

Let $\genT$ and $\genU$ be sets of elements,
let $A$ and $B$ be groups over $\genT$ and $\genU$, 
and let $f$ map $\genT$ to $\genU$.
The map $f$ is said to {\em preserve the inverses} if it maps the inverses of elements of $A$
to the inverses of the corresponding elements of $B$.

Let $MapPreservesInverse$ denote this situation.

\begin{schema}{MapPreservesInverse}[\genT, \genU]
f: \genT \fun \genU \\
A: \group \genT \\
B: \group \genU
\where
\LET (\_ \invG) == inverse\_operation~A; \\
\t1	(\_ \daggerG) == inverse\_operation~B @ \\
\t2		\forall x: \genT @ \\
\t3			f(x \invG) = (f~x) \daggerG
\end{schema}

\subsection{\zcmd{homGroup}}

Let $A$ and $B$ be groups.
A {\em group homomorphism} from $A$ to $B$ is a monoid homomorphism
from $A$ to $B$ that preserves inverses.

Let $\homGroup(A, B)$ denote the set of all group homomorphisms from $A$ to $B$.

\begin{gendef}[\genT, \genU]
\homGroup: \group \genT \cross \group \genU \fun \power (\genT \fun \genU)
\where
\homGroup = \\
\t1	(\lambda A: \group \genT; B: \group \genU @ \\
\t2		\{~ f: \homMonoid(A, B) | \\
\t3			MapPreservesInverse[\genT, \genU] ~\})
\end{gendef}

\begin{remark}
The identity mapping is a group homomorphism.
\end{remark}

\begin{remark}
The composition of two group homomorphisms is another group homomorphism.
\end{remark}

\subsection{$bij$}

Let $\genT$ be a set and let $bij[\genT]$ denote the set of a bijections $\genT \bij \genT$ from $\genT$ to itself.

\begin{gendef}[\genT]
	bij: \power (\genT \fun \genT)
\where
	bij = \genT \bij \genT
\end{gendef}

\begin{remark}
The composition of bijections is a bijection.

\begin{zed}
	\forall f, g: bij[\setT] @ \\
	\t1	f \circ g \in bij[\setT]
\end{zed}

\end{remark}

\begin{remark}
Composition is associative.

\begin{zed}
	\forall f, g, h: bij[\setT] @ \\
	\t1	f \circ (g \circ h) = (f \circ g) \circ h
\end{zed}

\end{remark}

\begin{remark}
The identity function $\id \setT$ acts as a left and right identity element under composition.

\begin{zed}
	\forall f: bij[\setT] @ \\
	\t1	 \id \setT \circ f = f = f \circ \id \setT
\end{zed}

\end{remark}

\begin{remark}
The inverse $f \inv$ of a bijection $f$ is its left and right inverse under composition.

\begin{zed}
	\forall f: bij[\setT] @ \\
	\t1	f \circ f \inv = \id \setT = f \inv \circ f
\end{zed}

\end{remark}

\subsection{$Bij$}

The preceding remarks show that set $bij[\genT]$ under the operation of composition has the structure of a group.
Let $Bij[\genT]$ denote this group.

\begin{gendef}[\genT]
	Bij: bij[\genT] \cross bij[\genT] \fun bij[\genT]
\where
	Bij = (\lambda f, g: bij[\genT] @ f \circ g)
\end{gendef}

\begin{example}
Let $\setT$ be any non-empty set.
The composition operation $Bij[\setT]$ is a group over the set of bijections $bij[\setT]$ from $\setT$ to $\setT$.

\begin{zed}
\setT \neq \emptyset \implies \\
\t1	Bij[\setT] \in \group bij[\setT]
\end{zed}

\end{example}

\section{Abelian Groups}

\subsection{OperationIsCommutative}

Let $\genT$ be a set of elements.
A binary operation $A$ over $\genT$ is said to be {\em commutative} when the product of two elements doesn't depend on 
their order.

Let $OperationIsCommutative$ denote this situation.

\begin{schema}{OperationIsCommutative}[\genT]
A: \binop \genT
\where
\LET (\_ \mulG \_) == A @ \\
\t1	\forall x, y: \genT @ \\
\t2		x \mulG y = y \mulG x
\end{schema}

\subsection{\zcmd{abgroup}}

An {\em Abelian group} is a group in which the binary operation is commutative.
Let $\genT$ be a set of elements.

Let $\abgroup \genT$ denote the set of all Abelian groups over $\genT$.

\begin{zed}
\abgroup \genT == \{~ A: \group \genT | OperationIsCommutative[\genT] ~\}
\end{zed}

\subsection{\zcmd{addG}, \zcmd{zeroG}, and \zcmd{negG}}

Often in an Abelian group the binary operation is denoted as addition $x \addG y$,
the identity element as a zero $\zeroG$, and the inverse operation as negation $\negG x$.

\begin{example}
Addition over the integers is an Abelian group.

\begin{zed}
	(\_ + \_) \in \abgroup \num
\end{zed}

\end{example}

\printbibliography

\end{document}