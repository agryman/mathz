%
% fuzzlib.x
%
% This file is part of fuzz2000
% Copyright (c) 1982--2006 J. M. Spivey
% All rights reserved
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
%
% 1. Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
% 2. Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
% 3. The name of the author may not be used to endorse or promote products
%    derived from this software without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
% IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
% OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
% IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
% SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
% PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
% OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
% WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
% OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
% ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
% 
% $Id: fuzzlib.x,v 1.2 2007-02-16 12:45:13 mike Exp $
%

%%token $"\bind" 335
%%token $"\bsup" 262
%%token $"\cross" 266
%%token $"\defs" 268
%%token $"\ELSE" 333
%%token $"\esup" 275
%%token $"\exists" 277
%%token $"\exists_1" 278
%%token $"false" 280
%%token $"\forall" 282
%%token $"\hide" 284
%%token $"\iff" 273
%%token $"\IF" 331
%%token $"\implies" 285
%%token $"\in" 286
%%token $"\inrel" 329
%%token $"\lambda" 289
%%token $"\land" 258
%%token $"\langle" 334
%%token $"\lbag" 290
%%token $"\ldata" 291
%%token $"\LET" 292
%%token $"\limg" 293
%%token $"\lnot" 296
%%token $"\lor" 298
%%token $"\mid" 124
%%token $"\mu" 294
%%token $"\pipe" 299
%%token $"\power" 300
%%token $"\pre" 301
%%token $"\project" 302
%%token $"\rangle" 336
%%token $"\rbag" 303
%%token $"\rdata" 304
%%token $"\rimg" 305
%%token $"\semi" 281
%%token $"\spot" 64
%%token $"\THEN" 332
%%token $"\theta" 306
%%token $"true" 307
%%token $"\vdash" 309
%%token $"\where" 310
%%token $"==" 272
%%token $"%%ingen" 312
%%token $"%%inop" 313
%%token $"%%inrel" 314
%%token $"%%pregen" 316
%%token $"%%prerel" 317
%%token $"%%postop" 315
%%token $"%%type" 318
%%token $"%%tame" 319
%%token $"%%pname" 320
%%token $"%%ignore" 338
%%token $"%%debug" 340
%%token $"%%line" 341
%%token $"\begin{axdef}" 259
%%token $"\begin{gendef}" 260
%%token $"\begin{schema}" 261
%%token $"\begin{zed}" 264
%%token $"\begin{syntax}" 263
%%token $"\end{axdef}" 270
%%token $"\end{gendef}" 271
%%token $"\end{schema}" 274
%%token $"\end{zed}" 279
%%token $"\end{syntax}" 276

%%inop \mapsto							1
%%inop \upto							2
%%inop + - \cup \setminus \cat \uplus \uminus			3
%%inop * \div \mod \cap \circ \comp \filter \extract \otimes	4
%%inop \oplus \bcount						5
%%inop \dres \rres \ndres \nrres				6
%%postop \plus \star \inv
%%inrel \neq \notin \subseteq \subset < \leq \geq > \inbag \partition
%%inrel \prefix \subbageq \suffix \inseq
%%prerel \disjoint
%%ingen \rel \fun \pinj \inj \psurj \surj \bij \ffun \finj
%%pregen \power_1 \id \finset \iseq
%%ignore \quad \qquad

%%type \pfun \nat \seq \bag
\begin{gendef}[X]
	\finset \_: \power (\power X)
\end{gendef}
\begin{gendef}[X,Y]
	\_ \rel \_, \_ \ffun \_: \power (\power (X \cross Y)) \\
	\_ \fun \_: \power (X \pfun Y)
\end{gendef}
%%type \rel \ffun \finset

\begin{axdef}
	-: \num \fun \num \\
        \_ + \_ , \_ - \_ , \_ * \_: \num \cross \num \fun \num \\
        \_ \div \_ , \_ \mod \_: 
		\num \cross \num \pfun \num \\
        \_ < \_ , \_ \leq \_ , \_ \geq \_ , \_ > \_: 
		\num \rel \num \\
	\nat_1: \power \nat \\
        succ: \nat \fun \nat \\
	\_ \upto \_: \num \cross \num \fun \power \num \\
        min: \power \num \pfun \num \\
        max: \power \num \pfun \num
\end{axdef}

\begin{gendef}[X]
        \_ \neq \_: X \rel X \\
        \_ \notin \_: X \rel \power X \\
	\empty, \emptyset: \power X \\
	\_ \subseteq \_ , \_ \subset \_: \power X \rel \power X \\
	\power_1 \_: \power (\power X) \\
        \_  \cup \_ , \_ \cap \_ , \_ \setminus \_:
                \power X \cross \power X \fun \power X \\
        \bigcup, \bigcap: \power (\power X) \fun \power X \\
	\id \_: X \rel X \\
        \_\plus, \_\star: (X \rel X) \fun (X \rel X) \\
        iter: \num \fun (X \rel X) \fun (X \rel X) \\
	\finset_1 \_: \power (\finset X) \\
        \#: \finset X \fun \nat \\
	\seq_1 \_, \iseq \_: \power (\seq X) \\
        \_ \cat \_ :  \seq X \cross \seq X \fun \seq X \\
        head, last: \seq X \pfun X \\
        tail, front: \seq X \pfun \seq X \\
        rev: \seq X \fun \seq X \\
        \_ \filter \_: \seq X \cross \power X \fun \seq X \\
        \_ \extract \_: \power \nat \cross \seq X \pfun \seq X \\
	squash: (\nat \ffun X) \pfun \seq X \\
	\_\prefix\_, \_\suffix\_, \_\inseq\_: \seq X \rel \seq X \\
        \dcat: \seq (\seq X) \fun \seq X \\
        count: \bag X \fun (X \fun \nat) \\
	\_\bcount\_: \bag X \cross X \fun \nat \\
        \_ \inbag \_: X \rel \bag X \\
	\_ \subbageq \_: \bag X \rel \bag X \\
        \_ \uplus \_, \_ \uminus \_: \bag X \cross \bag X \fun \bag X \\
	\_ \otimes \_: \nat \cross \bag X \fun \bag X \\
        items: \seq X \fun \bag X
\end{gendef}

\begin{gendef}[X,Y]
        first: X \cross Y \fun X \\
        second: X \cross Y \fun Y \\
        \_ \mapsto \_: X \cross Y \fun X \cross Y \\
        \dom: (X \rel Y) \fun \power X \\
        \ran: (X \rel Y) \fun \power Y \\
        \_ \dres \_: \power X \cross (X \rel Y) \fun (X \rel Y) \\
        \_ \rres \_: (X \rel Y) \cross \power Y \fun (X \rel Y) \\
        \_ \ndres \_: \power X \cross (X \rel Y) \fun (X \rel Y) \\
        \_ \nrres \_: (X \rel Y) \cross \power Y \fun (X \rel Y) \\
        \_\inv: (X \rel Y) \fun (Y \rel X) \\
        \_\limg\_\rimg: (X \rel Y) \cross \power X \fun \power Y \\
        \_ \oplus \_: (X \rel Y) \cross (X \rel Y) \fun (X \rel Y) \\
	\_ \pinj \_, \_ \inj \_, \_ \psurj \_, 
	\_ \surj \_, \_ \bij \_, \_ \finj \_: \power(X \pfun Y) \\
        \disjoint \_: \power (X \pfun \power Y) \\
        \_ \partition \_: (X \pfun \power Y) \rel \power Y
\end{gendef}

\begin{gendef}[X,Y,Z]
        \_ \comp \_: (X \rel Y) \cross (Y \rel Z) \fun (X \rel Z) \\
	\_ \circ \_: (Y \rel Z) \cross (X \rel Y) \fun (X \rel Z)
\end{gendef}

%%pname \pfun $"-+>"
%%pname \ffun $"-++>"
%%pname \rel $"<->"
%%pname \seq $"seq"
%%pname \bag $"bag"
%%pname \finset $"F"
%%pname \nat $"NN"
%%pname \num $"ZZ"
%%pname \upto $".."
%%pname \# $"#"
%%pname \power_1 $"P_1"
%%pname \id $"id"
%%pname \mapsto $"|->"
%%pname \dom $"dom"
%%pname \ran $"ran"
%%pname \fun $"-->"
%%pname \pinj $">+>"
%%pname \inj $">->"
%%pname \psurj $"-+>>"
%%pname \surj $"-->>"
%%pname \bij $">->>"
%%pname \finj $">++>"
%%pname \disjoint $"disjoint"
%%pname \partition $"partition"

%%tame \cup \cap \setminus \bigcup \bigcap count \uplus items
%%tame \plus \cat head last tail front rev \filter \dcat
%%tame first second \mapsto \dom \ran \dres \rres \ndres \nrres 
%%tame \inv \limg\rimg \oplus \comp \circ
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{amsmath}
\ProvidesPackage{mathz-sets}[2022/02/01 Z Notation for sets package]

% sets

% formal parameters for generic constructions
\newcommand{\genA}{\mathsf{a}}
\newcommand{\genB}{\mathsf{b}}
\newcommand{\genC}{\mathsf{c}}
\newcommand{\genD}{\mathsf{d}}
\newcommand{\genE}{\mathsf{e}}
\newcommand{\genF}{\mathsf{f}}
\newcommand{\genG}{\mathsf{g}}
\newcommand{\genH}{\mathsf{h}}
\newcommand{\genI}{\mathsf{i}}
\newcommand{\genJ}{\mathsf{j}}
\newcommand{\genK}{\mathsf{k}}
\newcommand{\genL}{\mathsf{l}}
\newcommand{\genM}{\mathsf{m}}
\newcommand{\genN}{\mathsf{n}}
\newcommand{\genO}{\mathsf{o}}
\newcommand{\genP}{\mathsf{p}}
\newcommand{\genQ}{\mathsf{q}}
\newcommand{\genR}{\mathsf{r}}
\newcommand{\genS}{\mathsf{s}}
\newcommand{\genT}{\mathsf{t}}
\newcommand{\genU}{\mathsf{u}}
\newcommand{\genV}{\mathsf{v}}
\newcommand{\genW}{\mathsf{w}}
\newcommand{\genX}{\mathsf{x}}
\newcommand{\genY}{\mathsf{y}}
\newcommand{\genZ}{\mathsf{z}}

% arbitrary sets used in theorems, remarks, and examples involving generic constructs
\newcommand{\setA}{\mathsf{A}}
\newcommand{\setB}{\mathsf{B}}
\newcommand{\setC}{\mathsf{C}}
\newcommand{\setD}{\mathsf{D}}
\newcommand{\setE}{\mathsf{E}}
\newcommand{\setF}{\mathsf{F}}
\newcommand{\setG}{\mathsf{G}}
\newcommand{\setH}{\mathsf{H}}
\newcommand{\setI}{\mathsf{I}}
\newcommand{\setJ}{\mathsf{J}}
\newcommand{\setK}{\mathsf{K}}
\newcommand{\setL}{\mathsf{L}}
\newcommand{\setM}{\mathsf{M}}
\newcommand{\setN}{\mathsf{N}}
\newcommand{\setO}{\mathsf{O}}
\newcommand{\setP}{\mathsf{P}}
\newcommand{\setQ}{\mathsf{Q}}
\newcommand{\setR}{\mathsf{R}}
\newcommand{\setS}{\mathsf{S}}
\newcommand{\setT}{\mathsf{T}}
\newcommand{\setU}{\mathsf{U}}
\newcommand{\setV}{\mathsf{V}}
\newcommand{\setW}{\mathsf{W}}
\newcommand{\setX}{\mathsf{X}}
\newcommand{\setY}{\mathsf{Y}}
\newcommand{\setZ}{\mathsf{Z}}

% families of sets
%%pregen \Fam
\DeclareMathOperator{\Fam}{\mathcal{F}}

% the induced family infix operator
%%inop \inducedFam 6
\newcommand{\inducedFam}{\mathbin{|_{\Fam}}}

% the product family infix operator
%%inop \prodFam 5
\newcommand{\prodFam}{\mathbin{\cross_{\Fam}}}

% the constant function
\DeclareMathOperator{\const}{const}

% the function restriction infix operator
%%inop \restrictU 6
\newcommand{\restrictU}{\mathbin{|}}

% the set of binary digits
\newcommand{\B}{\mathbb{B}}

% the indicator function of a set
%%pregen \indF
\DeclareMathOperator{\indF}{\mathbf{1}}

% the delta function of a set
%%pregen \deltaF
\DeclareMathOperator{\deltaF}{\delta}
\documentclass{amsart}

\usepackage{mathz-sets}
\usepackage{mathz-preamble}
\usepackage{amsmath}

\addbibresource{../../shared/references.bib}

\begin{document}

\title{Sets}
\author{Arthur Ryman}
\email[Arthur Ryman]{arthur.ryman@gmail.com}
\date{\today}

\begin{abstract}
This article contains \ZN\ definitions for 
concepts related to sets.
It has been type checked by \fuzz.
\end{abstract}

\maketitle

\tableofcontents

\section{Introduction}

Typed set theory forms the mathematical foundation of \ZN\
and many set theory concepts are defined in its built-in mathematical toolkit. 
This articles augments the toolkit with some additional concepts.

\section{Binary Digits}

Let $bit$ denote the set of \textit{binary digits}, namely the set $\{ 0, 1\} \subseteq \num$.

\begin{zed}
	bit == \{ 0, 1 \}
\end{zed}

We introduce the notation $\B = bit$.

\begin{zed}
	\B == bit
\end{zed}

\section{Arbitrary Sets}

\ZN\ supports generic constructions which take arbitrary sets as parameters.
It is often of interest to state theorems, remarks, and examples about generic constructions that hold for arbitrary sets.
However, \ZN\ does not allow universal quantification over the set of all sets since this leads to the Russell paradox.
In fact, typed set theory was motivated by a desire to avoid the Russell paradox.

As a workaround, we adopt the convention of stating theorems, remarks, and example that hold for arbitrary sets in terms
of predefined given sets with the understanding that these sets are completely unconstrained by additional axioms.

It is an error to use any of these predefined sets outside of the statement of a theorem, remark, or example.

Let $\setA, \setB, \dots \setZ$ denote these predefined arbitrary sets.

\begin{zed}
	[\setA, \setB, \setC, \setD, \setE, \setF, \setG, \setH, \setI, \setJ, \setK, \setL, \setM, 
	\setN, \setO, \setP, \setQ, \setR, \setS, \setT, \setU, \setV, \setW, \setX, \setY, \setZ]
\end{zed}

For example, consider the following statement which holds for the arbitrary set $\setX$.

\begin{remark}
Equality is reflexive.
\begin{zed}
	\forall x: \setX @ x = x
\end{zed}
\end{remark}

\section{Formal Generic Parameters}

Formal generic parameters appear in the definition of generic schemas and constants where
they are used as placeholders for arbitrary sets.
As a purely stylistic convention, we use the following typographically distinctive symbols as formal generic parameters:
\begin{equation*}
	\genA, \genB, \dots, \genZ
\end{equation*}

\section{Families of Subsets}

Let $\genT$ be a set.
A \textit{family} of subsets of $\genT$ is a set of subsets of $\genT$.
Let $Fam[\genT]$ denote the set of all families of subsets of $\genT$.

\begin{zed}
	Fam[\genT] == \power(\power \genT)
\end{zed}

\begin{example}
The set consisting of the empty set and $\setX$ is a family of subsets of $\setX$.
\begin{zed}
	\{ \emptyset, \setX \} \in Fam[\setX]
\end{zed}
\end{example}

Let the prefix generic symbol $\Fam \genT$ denote the family of subsets of $\genT$ .

\begin{zed}
	\Fam \genT == Fam[\genT]
\end{zed}

\section{Functions}

\subsection{Constant Functions}

Let $\genT$ and $\genU$ be sets and let $c \in \genU$ be some given element.
The mapping $f(x) = c$ that sends every element $x \in \genT$ to $c$ is called the \textit{constant function} on $\genT$ with value $c$.

\begin{schema}{ConstantFunction}[\genT, \genU]
	c: \genU \\
	f: \genT \fun \genU
\where
	f = (\lambda x: \genT @ c)
\end{schema}

Let the function $constant\_function~c = f$ denote the constant function $f: \genT \fun \genU$ with value $c$.

\begin{zed}
	constant\_function[\genT, \genU] == \{~ConstantFunction[\genT, \genU] @ c \mapsto f ~\}
\end{zed}

\begin{remark}
The mapping $constant\_function$ maps each element $c \in \setU$ to a function $\setT \fun \setU$.
\begin{zed}
	constant\_function[\setT, \setU] \in \setU \fun (\setT \fun \setU)
\end{zed}
\end{remark}

Let the notation $\const c$ denote the constant function defined by $c$.

\begin{zed}
	\const[\genT, \genU] == constant\_function[\genT, \genU]
\end{zed}

\begin{remark}
\begin{zed}
	\forall c: \setU; x: \setT @ \const[\setT, \setU] c~x = c
\end{zed}
\end{remark}

\subsection{Delta Functions}

Let $\genT$ be a set and let $x, y \in \genT$. 
Define the \textit{equality indicator bit} $z$ to be $1$ if $x = y$ and $0$ otherwise.

\begin{schema}{EqualityIndicator}[\genT]
	x, y: \genT \\
	z: \B
\where
	z = \IF x = y \THEN 1 \ELSE 0
\end{schema}

Define the delta function $delta(x, y) = z$.

\begin{zed}
	delta[\genT] == \{~ EqualityIndicator[\genT] @ (x, y) \mapsto z ~\}
\end{zed}

\begin{remark}
\begin{zed}
	delta[\setX] \in \setX \cross \setX \fun \B
\end{zed}
\end{remark}

\begin{example}
\begin{zed}
	delta(0, 0) = 1
\also
	delta(0, 1) = 0
\end{zed}
\end{example}

\begin{theorem}
\begin{zed}
	\forall x: \setX @ \\
	\t1	delta(x, x) = 1
\end{zed}
\end{theorem}

We introduce the usual notation $\deltaF \genT = delta[\genT]$.

\begin{zed}
	\deltaF \genT == delta[\genT]
\end{zed}

\begin{example}
\begin{zed}
	(\deltaF \num) (0,1) = 0
\end{zed}
\end{example}

\subsection{Function Restriction}

Let $\genT$ and $\genU$ be sets, let $f: \genT \fun \genU$, and let $T \subseteq \genT$ be a subset.
Let $g$ denote the restriction of $f$ to $T$.

\begin{schema}{FunctionRestriction}[\genT, \genU]
	f: \genT \fun \genU \\
	T: \power \genT \\
	g: \genT \pfun \genU
\where
	g = T \dres f
\end{schema}

Let the function  $g = restriction(f, T)$ denote the restriction of $f$ to $T$.

\begin{zed}
	restriction[\genT, \genU] == \{~ FunctionRestriction[\genT, \genU] @ (f, T) \mapsto g ~\}
\end{zed}

Let the generic infix operator $f \restrictU T$ denote the restriction of $f$ to $T$.

\begin{zed}
	(\_ \restrictU \_)[\genT, \genU] == restriction[\genT, \genU]
\end{zed}

\begin{remark}
Function restriction is domain restriction with arguments reversed.
\begin{zed}
	\forall FunctionRestriction[\setT, \setU] @ \\
	\t1	f \restrictU T = T \dres f
\end{zed}
\end{remark}

\subsection{Indicator Functions}

Let $\genT$ be a set and let $X \subseteq \genT$ be a subset.
The \textit{indicator function}  $f$  of $X$ maps each element $a \in \genT$ to 1 if $a \in X$ and 0 otherwise.
The indicator function is also referred to as the \textit{characteristic function} of $X$.

\begin{schema}{IndicatorFunction}[\genT]
	X: \power \genT \\
	f: \genT \fun \B
\where
	f = (\lambda a: \genT @ \IF a \in X \THEN 1 \ELSE 0)
\end{schema}

Let $indicator\_function~X = f$ denote the indicator function of $X$.

\begin{zed}
	indicator\_function[\genT] == \{~ IndicatorFunction[\genT] @ X \mapsto f ~\}
\end{zed}

\begin{remark}
For each subset $X \subseteq \setT$, the indicator function of $X$ is a binary function on $\setT$.
\begin{zed}
	indicator\_function[\setT] \in \power \setT \fun \setT \fun \B
\end{zed}
\end{remark}

We introduce the prefix generic symbol $(\indF \_)$ where $(\indF \genT)X = indicator\_function[\genT] X$.

\begin{zed}
	\indF \genT == indicator\_function[\genT]
\end{zed}

\begin{remark}
The domain of the range restriction of the indicator function of a set $X$ to the range $\{1\}$ is $X$.
\begin{zed}
	\forall X: \power \setT @ \\
	\t1	\dom((\indF \setT)X \rres \{1\}) = X
\end{zed}
\end{remark}

\section{The Support of a Function}

Let $\genT$ be a set and let $f: \genT \fun \num$ be an integer-valued function.
The \textit{support} $S$ of $f$ is the set of elements $x \in \genT$ where $f~x \neq 0$.

\begin{schema}{FunctionSupport}[\genT]
	f: \genT \fun \num \\
	S: \power \genT
\where
	S = \{~ x: \genT | f~x \neq 0 ~\}
\end{schema}

Let the function $S = support~f$ denote the support of $f$.

\begin{zed}
	support[\genT] == \{~ FunctionSupport[\genT] @ f \mapsto S ~\}
\end{zed}

\begin{example}
The support of the indicator function of a set $X$ is $X$.
\begin{zed}
	\forall X: \power \setT @ \\
	\t1 support((\indF \setT)X) = X
\end{zed}
\end{example}

An integer-valued function is said to have \textit{finite support} if its support is a finite set.

\begin{schema}{FiniteSupport}[\genT]
	FunctionSupport[\genT]
\where
	S \in \finset \genT
\end{schema}

Let $finite\_support[\genT]$ denote the set of all integer-valued functions on $\genT$ that have finite support.

\begin{zed}
	finite\_support[\genT] == \{~ FiniteSupport[\genT] @ f ~\}
\end{zed}

\begin{remark}
\begin{zed}
	finite\_support[\setT] \subseteq \setT \fun \num
\end{zed}
\end{remark}

\printbibliography

\end{document}\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{mathz-categories}[2022/09/23 Z Notation for categories]

\RequirePackage{amssymb}
\RequirePackage{amsmath}

% categories

% the domain of an arrow
\DeclareMathOperator{\domCat}{dom}

% the codomain of an arrow
\DeclareMathOperator{\codCat}{cod}

% the arrow infix operator f -> g
%%inop \arrCat 1
\newcommand{\arrCat}{\mathbin{\rightarrow}}

% the identity arrow of an object
\DeclareMathOperator{\idCat}{id}

% the composition infix operator g o f
%%inop \compCat 4
\newcommand{\compCat}{\mathbin{\circ}}
